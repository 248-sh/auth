schema {
  query: Query
  mutation: Mutation
}

directive @oneOf on OBJECT | INTERFACE

directive @statusCodeTypeName(typeName: String, statusCode: ID) repeatable on UNION

directive @enum(value: String) on ENUM_VALUE

directive @globalOptions(sourceName: String, endpoint: String, operationHeaders: ObjMap, queryStringOptions: ObjMap, queryParams: ObjMap) on OBJECT

directive @httpOperation(path: String, operationSpecificHeaders: ObjMap, httpMethod: HTTPMethod, isBinary: Boolean, requestBaseBody: ObjMap, queryParamArgMap: ObjMap, queryStringOptionsByParam: ObjMap) on FIELD_DEFINITION

type Query @globalOptions(sourceName: "kratos-admin", endpoint: "http://localhost:4434") {
  auth: authQuery!
}

union isAlive_response @statusCodeTypeName(statusCode: 200, typeName: "isAlive_200_response") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = isAlive_200_response | genericError

type isAlive_200_response {
  "Always \"ok\"."
  status: String!
}

"The standard error format"
type genericError {
  code: Int
  details: JSON
  message: String
  reason: String
  request: String
  status: String
}

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

union isReady_response @statusCodeTypeName(statusCode: 200, typeName: "isReady_200_response") @statusCodeTypeName(statusCode: 503, typeName: "isReady_503_response") = isReady_200_response | isReady_503_response

type isReady_200_response {
  "Always \"ok\"."
  status: String!
}

type isReady_503_response {
  "Errors contains a list of errors that caused the not ready status."
  errors: JSON!
}

union getRelationTuples_response @statusCodeTypeName(statusCode: 200, typeName: "getRelationTuplesResponse") @statusCodeTypeName(statusCode: 404, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = getRelationTuplesResponse | genericError

type getRelationTuplesResponse {
  "The opaque token to provide in a subsequent request\nto get the next page. It is the empty string iff this is\nthe last page."
  next_page_token: String
  relation_tuples: [relationTuple]
}

type relationTuple {
  "Namespace of the Relation Tuple"
  namespace: String!
  "Object of the Relation Tuple"
  object: String!
  "Relation of the Relation Tuple"
  relation: String!
  "SubjectID of the Relation Tuple\n\nEither SubjectSet or SubjectID can be provided."
  subject_id: String
  subject_set: subjectSet
}

type subjectSet {
  "Namespace of the Subject Set"
  namespace: String!
  "Object of the Subject Set"
  object: String!
  "Relation of the Subject Set"
  relation: String!
}

union getCheckMirrorStatus_response @statusCodeTypeName(statusCode: 200, typeName: "RESTResponse_represents_the_response_for_a_check_request_") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 403, typeName: "RESTResponse_represents_the_response_for_a_check_request_") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = RESTResponse_represents_the_response_for_a_check_request_ | genericError

"The content of the allowed field is mirrored in the HTTP status code."
type RESTResponse_represents_the_response_for_a_check_request_ {
  "whether the relation tuple is allowed"
  allowed: Boolean!
}

union getCheck_response @statusCodeTypeName(statusCode: 200, typeName: "RESTResponse_represents_the_response_for_a_check_request_") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = RESTResponse_represents_the_response_for_a_check_request_ | genericError

union getExpand_response @statusCodeTypeName(statusCode: 200, typeName: "expandTree") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 404, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = expandTree | genericError

type expandTree {
  "The children of the node, possibly none."
  children: [expandTree]
  tuple: relationTuple
  type: query_getExpand_oneOf_0_type!
}

"The type of the node.\nunion TreeNodeUnion\nexclusion TreeNodeExclusion\nintersection TreeNodeIntersection\nleaf TreeNodeLeaf\ntuple_to_subject_set TreeNodeTupleToSubjectSet\ncomputed_subject_set TreeNodeComputedSubjectSet\nnot TreeNodeNot\nunspecified TreeNodeUnspecified"
enum query_getExpand_oneOf_0_type {
  union
  exclusion
  intersection
  leaf
  tuple_to_subject_set
  computed_subject_set
  not
  unspecified
}

type getVersion_200_response {
  "The version of Ory Kratos."
  version: String!
}

type Mutation {
  auth: authMutation!
}

union deleteRelationTuples_response @statusCodeTypeName(statusCode: 204, typeName: "Void_container") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = Void_container | genericError

type Void_container {
  Void: Void
}

"Represents empty values"
scalar Void

union patchRelationTuples_response @statusCodeTypeName(statusCode: 204, typeName: "Void_container") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 404, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = Void_container | genericError

input patchDelta_Input {
  action: mutationInput_patchRelationTuples_input_items_action
  relation_tuple: relationTuple_Input
}

enum mutationInput_patchRelationTuples_input_items_action {
  insert
  delete
}

input relationTuple_Input {
  "Namespace of the Relation Tuple"
  namespace: String!
  "Object of the Relation Tuple"
  object: String!
  "Relation of the Relation Tuple"
  relation: String!
  "SubjectID of the Relation Tuple\n\nEither SubjectSet or SubjectID can be provided."
  subject_id: String
  subject_set: subjectSet_Input
}

input subjectSet_Input {
  "Namespace of the Subject Set"
  namespace: String!
  "Object of the Subject Set"
  object: String!
  "Relation of the Subject Set"
  relation: String!
}

union createRelationTuple_response @statusCodeTypeName(statusCode: 201, typeName: "relationQuery") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = relationQuery | genericError

type relationQuery {
  "Namespace to query"
  namespace: String
  "Object to query"
  object: String
  "Relation to query"
  relation: String
  "SubjectID to query\n\nEither SubjectSet or SubjectID can be provided."
  subject_id: String
  subject_set: subjectSet
}

input relationQuery_Input {
  "Namespace to query"
  namespace: String
  "Object to query"
  object: String
  "Relation to query"
  relation: String
  "SubjectID to query\n\nEither SubjectSet or SubjectID can be provided."
  subject_id: String
  subject_set: subjectSet_Input
}

union postCheckMirrorStatus_response @statusCodeTypeName(statusCode: 200, typeName: "RESTResponse_represents_the_response_for_a_check_request_") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 403, typeName: "RESTResponse_represents_the_response_for_a_check_request_") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = RESTResponse_represents_the_response_for_a_check_request_ | genericError

union postCheck_response @statusCodeTypeName(statusCode: 200, typeName: "RESTResponse_represents_the_response_for_a_check_request_") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = RESTResponse_represents_the_response_for_a_check_request_ | genericError

scalar ObjMap

enum HTTPMethod {
  GET
  HEAD
  POST
  PUT
  DELETE
  CONNECT
  OPTIONS
  TRACE
  PATCH
}

type authQuery {
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/health/alive`\nThis endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming\nHTTP requests. This status does currently not include checks whether the database connection is working.\n\nIf the service supports TLS Edge Termination, this endpoint does not require the\n`X-Forwarded-Proto` header to be set.\n\nBe aware that if you are running multiple nodes of this service, the health status will never\nrefer to the cluster state, only to a single instance.\n"
  isAlive: isAlive_response @httpOperation(path: "/health/alive", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/health/ready`\nThis endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g.\nthe database) are responsive as well.\n\nIf the service supports TLS Edge Termination, this endpoint does not require the\n`X-Forwarded-Proto` header to be set.\n\nBe aware that if you are running multiple nodes of Ory Keto, the health status will never\nrefer to the cluster state, only to a single instance.\n"
  isReady: isReady_response @httpOperation(path: "/health/ready", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/relation-tuples`\nGet all relation tuples that match the query. Only the namespace field is required.\n"
  getRelationTuples(
    page_token: String
    page_size: Int
    "Namespace of the Relation Tuple"
    namespace: String
    "Object of the Relation Tuple"
    object: String
    "Relation of the Relation Tuple"
    relation: String
    "SubjectID of the Relation Tuple"
    subject_id: String
    "Namespace of the Subject Set"
    subject_set_namespace: String
    "Object of the Subject Set"
    subject_set_object: String
    "Relation of the Subject Set"
    subject_set_relation: String
  ): getRelationTuples_response @httpOperation(path: "/relation-tuples", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"page_token\":\"page_token\",\"page_size\":\"page_size\",\"namespace\":\"namespace\",\"object\":\"object\",\"relation\":\"relation\",\"subject_id\":\"subject_id\",\"subject_set.namespace\":\"subject_set_namespace\",\"subject_set.object\":\"subject_set_object\",\"subject_set.relation\":\"subject_set_relation\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/relation-tuples/check`\nTo learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).\n"
  getCheckMirrorStatus: getCheckMirrorStatus_response @httpOperation(path: "/relation-tuples/check", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/relation-tuples/check/openapi`\nTo learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).\n"
  getCheck(
    "Namespace of the Relation Tuple"
    namespace: String
    "Object of the Relation Tuple"
    object: String
    "Relation of the Relation Tuple"
    relation: String
    "SubjectID of the Relation Tuple"
    subject_id: String
    "Namespace of the Subject Set"
    subject_set_namespace: String
    "Object of the Subject Set"
    subject_set_object: String
    "Relation of the Subject Set"
    subject_set_relation: String
    max_depth: Int
  ): getCheck_response @httpOperation(path: "/relation-tuples/check/openapi", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"namespace\":\"namespace\",\"object\":\"object\",\"relation\":\"relation\",\"subject_id\":\"subject_id\",\"subject_set.namespace\":\"subject_set_namespace\",\"subject_set.object\":\"subject_set_object\",\"subject_set.relation\":\"subject_set_relation\",\"max-depth\":\"max_depth\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/relation-tuples/expand`\nUse this endpoint to expand a relation tuple.\n"
  getExpand(
    "Namespace of the Subject Set"
    namespace: String!
    "Object of the Subject Set"
    object: String!
    "Relation of the Subject Set"
    relation: String!
    max_depth: Int
  ): getExpand_response @httpOperation(path: "/relation-tuples/expand", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"namespace\":\"namespace\",\"object\":\"object\",\"relation\":\"relation\",\"max-depth\":\"max_depth\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/version`\nThis endpoint returns the version of Ory Keto.\n\nIf the service supports TLS Edge Termination, this endpoint does not require the\n`X-Forwarded-Proto` header to be set.\n\nBe aware that if you are running multiple nodes of this service, the version will never\nrefer to the cluster state, only to a single instance.\n"
  getVersion: getVersion_200_response @httpOperation(path: "/version", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
}

type authMutation {
  "\n>**Method**: `DELETE`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/admin/relation-tuples`\nUse this endpoint to delete relation tuples\n"
  deleteRelationTuples(
    "Namespace of the Relation Tuple"
    namespace: String
    "Object of the Relation Tuple"
    object: String
    "Relation of the Relation Tuple"
    relation: String
    "SubjectID of the Relation Tuple"
    subject_id: String
    "Namespace of the Subject Set"
    subject_set_namespace: String
    "Object of the Subject Set"
    subject_set_object: String
    "Relation of the Subject Set"
    subject_set_relation: String
  ): deleteRelationTuples_response @httpOperation(path: "/admin/relation-tuples", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: DELETE, queryParamArgMap: "{\"namespace\":\"namespace\",\"object\":\"object\",\"relation\":\"relation\",\"subject_id\":\"subject_id\",\"subject_set.namespace\":\"subject_set_namespace\",\"subject_set.object\":\"subject_set_object\",\"subject_set.relation\":\"subject_set_relation\"}")
  "\n>**Method**: `PATCH`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/admin/relation-tuples`\nUse this endpoint to patch one or more relation tuples.\n"
  patchRelationTuples(input: [patchDelta_Input]): patchRelationTuples_response @httpOperation(path: "/admin/relation-tuples", operationSpecificHeaders: "{\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: PATCH)
  "\n>**Method**: `PUT`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/admin/relation-tuples`\nUse this endpoint to create a relation tuple.\n"
  createRelationTuple(input: relationQuery_Input): createRelationTuple_response @httpOperation(path: "/admin/relation-tuples", operationSpecificHeaders: "{\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: PUT)
  "\n>**Method**: `POST`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/relation-tuples/check`\nTo learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).\n"
  postCheckMirrorStatus: postCheckMirrorStatus_response @httpOperation(path: "/relation-tuples/check", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: POST)
  "\n>**Method**: `POST`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/relation-tuples/check/openapi`\nTo learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).\n"
  postCheck(max_depth: Int, input: relationQuery_Input): postCheck_response @httpOperation(path: "/relation-tuples/check/openapi", operationSpecificHeaders: "{\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: POST, queryParamArgMap: "{\"max-depth\":\"max_depth\"}")
}