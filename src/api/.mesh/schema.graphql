schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

directive @oneOf on OBJECT | INTERFACE

directive @statusCodeTypeName(typeName: String, statusCode: ID) repeatable on UNION

directive @enum(value: String) on ENUM_VALUE

directive @globalOptions(sourceName: String, endpoint: String, operationHeaders: ObjMap, queryStringOptions: ObjMap, queryParams: ObjMap) on OBJECT

directive @httpOperation(path: String, operationSpecificHeaders: ObjMap, httpMethod: HTTPMethod, isBinary: Boolean, requestBaseBody: ObjMap, queryParamArgMap: ObjMap, queryStringOptionsByParam: ObjMap) on FIELD_DEFINITION

directive @resolveRoot on FIELD_DEFINITION

directive @dictionary on FIELD_DEFINITION

directive @discriminator(field: String) on INTERFACE | UNION

directive @regexp(pattern: String) on SCALAR

directive @typescript(type: String) on SCALAR | ENUM

"""The root query type which gives access points into the data universe."""
type Query implements Node @globalOptions(sourceName: "kratos-admin", endpoint: "http://localhost:4434") {
  auth: authQuery!
  dummy: String
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!
  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!
  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node
  """Reads and enables pagination through a set of `Client`."""
  clients(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Client`."""
    orderBy: [ClientsOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientFilter
  ): ClientsConnection
  """Reads and enables pagination through a set of `Entry`."""
  entries(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Entry`."""
    orderBy: [EntriesOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EntryCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EntryFilter
  ): EntriesConnection
  """Reads and enables pagination through a set of `EntryTag`."""
  entryTags(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `EntryTag`."""
    orderBy: [EntryTagsOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EntryTagCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EntryTagFilter
  ): EntryTagsConnection
  """Reads and enables pagination through a set of `Project`."""
  projects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter
  ): ProjectsConnection
  """Reads and enables pagination through a set of `SchemaMigration`."""
  schemaMigrations(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `SchemaMigration`."""
    orderBy: [SchemaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SchemaMigrationCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SchemaMigrationFilter
  ): SchemaMigrationsConnection
  """Reads and enables pagination through a set of `Tag`."""
  tags(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TagFilter
  ): TagsConnection
  client(userId: String!, id: String!): Client
  clientByName(name: String!): Client
  entry(userId: String!, id: String!): Entry
  entryTag(userId: String!, entryId: String!, tagId: String!): EntryTag
  project(userId: String!, id: String!): Project
  projectByName(name: String!): Project
  schemaMigration(version: BigInt!): SchemaMigration
  tag(userId: String!, id: String!): Tag
  tagByName(name: String!): Tag
  """Reads a single `Client` using its globally unique `ID`."""
  clientByNodeId(
    """The globally unique `ID` to be used in selecting a single `Client`."""
    nodeId: ID!
  ): Client
  """Reads a single `Entry` using its globally unique `ID`."""
  entryByNodeId(
    """The globally unique `ID` to be used in selecting a single `Entry`."""
    nodeId: ID!
  ): Entry
  """Reads a single `EntryTag` using its globally unique `ID`."""
  entryTagByNodeId(
    """The globally unique `ID` to be used in selecting a single `EntryTag`."""
    nodeId: ID!
  ): EntryTag
  """Reads a single `Project` using its globally unique `ID`."""
  projectByNodeId(
    """The globally unique `ID` to be used in selecting a single `Project`."""
    nodeId: ID!
  ): Project
  """Reads a single `SchemaMigration` using its globally unique `ID`."""
  schemaMigrationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `SchemaMigration`.
    """
    nodeId: ID!
  ): SchemaMigration
  """Reads a single `Tag` using its globally unique `ID`."""
  tagByNodeId(
    """The globally unique `ID` to be used in selecting a single `Tag`."""
    nodeId: ID!
  ): Tag
}

type Mutation {
  auth: authMutation!
  hours: hoursMutation!
}

type isAlive_200_response {
  "Always \"ok\"."
  status: String!
}

"The standard error format"
type genericError {
  code: Int
  details: JSON
  message: String
  reason: String
  request: String
  status: String
}

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type isReady_200_response {
  "Always \"ok\"."
  status: String!
}

union getRelationTuples_response @statusCodeTypeName(statusCode: 200, typeName: "getRelationTuplesResponse") @statusCodeTypeName(statusCode: 404, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = getRelationTuplesResponse | genericError

type getRelationTuplesResponse {
  "The opaque token to provide in a subsequent request\nto get the next page. It is the empty string iff this is\nthe last page."
  next_page_token: String
  relation_tuples: [relationTuple]
}

type relationTuple {
  "Namespace of the Relation Tuple"
  namespace: String!
  "Object of the Relation Tuple"
  object: String!
  "Relation of the Relation Tuple"
  relation: String!
  "SubjectID of the Relation Tuple\n\nEither SubjectSet or SubjectID can be provided."
  subject_id: String
  subject_set: subjectSet
}

type subjectSet {
  "Namespace of the Subject Set"
  namespace: String!
  "Object of the Subject Set"
  object: String!
  "Relation of the Subject Set"
  relation: String!
}

union getCheckMirrorStatus_response @statusCodeTypeName(statusCode: 200, typeName: "RESTResponse_represents_the_response_for_a_check_request_") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 403, typeName: "RESTResponse_represents_the_response_for_a_check_request_") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = RESTResponse_represents_the_response_for_a_check_request_ | genericError

"The content of the allowed field is mirrored in the HTTP status code."
type RESTResponse_represents_the_response_for_a_check_request_ {
  "whether the relation tuple is allowed"
  allowed: Boolean!
}

union getCheck_response @statusCodeTypeName(statusCode: 200, typeName: "RESTResponse_represents_the_response_for_a_check_request_") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = RESTResponse_represents_the_response_for_a_check_request_ | genericError

union getExpand_response @statusCodeTypeName(statusCode: 200, typeName: "expandTree") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 404, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = expandTree | genericError

type expandTree {
  "The children of the node, possibly none."
  children: [expandTree]
  tuple: relationTuple
  type: query_getExpand_oneOf_0_type!
}

"The type of the node.\nunion TreeNodeUnion\nexclusion TreeNodeExclusion\nintersection TreeNodeIntersection\nleaf TreeNodeLeaf\ntuple_to_subject_set TreeNodeTupleToSubjectSet\ncomputed_subject_set TreeNodeComputedSubjectSet\nnot TreeNodeNot\nunspecified TreeNodeUnspecified"
enum query_getExpand_oneOf_0_type {
  union
  exclusion
  intersection
  leaf
  tuple_to_subject_set
  computed_subject_set
  not
  unspecified
}

type getVersion_200_response {
  "The version of Ory Kratos."
  version: String!
}

union deleteRelationTuples_response @statusCodeTypeName(statusCode: 204, typeName: "Void_container") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = Void_container | genericError

type Void_container {
  Void: Void
}

"Represents empty values"
scalar Void

union patchRelationTuples_response @statusCodeTypeName(statusCode: 204, typeName: "Void_container") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 404, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = Void_container | genericError

input patchDelta_Input {
  action: mutationInput_patchRelationTuples_input_items_action
  relation_tuple: relationTuple_Input
}

enum mutationInput_patchRelationTuples_input_items_action {
  insert
  delete
}

input relationTuple_Input {
  "Namespace of the Relation Tuple"
  namespace: String!
  "Object of the Relation Tuple"
  object: String!
  "Relation of the Relation Tuple"
  relation: String!
  "SubjectID of the Relation Tuple\n\nEither SubjectSet or SubjectID can be provided."
  subject_id: String
  subject_set: subjectSet_Input
}

input subjectSet_Input {
  "Namespace of the Subject Set"
  namespace: String!
  "Object of the Subject Set"
  object: String!
  "Relation of the Subject Set"
  relation: String!
}

union createRelationTuple_response @statusCodeTypeName(statusCode: 201, typeName: "relationQuery") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = relationQuery | genericError

type relationQuery {
  "Namespace to query"
  namespace: String
  "Object to query"
  object: String
  "Relation to query"
  relation: String
  "SubjectID to query\n\nEither SubjectSet or SubjectID can be provided."
  subject_id: String
  subject_set: subjectSet
}

input relationQuery_Input {
  "Namespace to query"
  namespace: String
  "Object to query"
  object: String
  "Relation to query"
  relation: String
  "SubjectID to query\n\nEither SubjectSet or SubjectID can be provided."
  subject_id: String
  subject_set: subjectSet_Input
}

union postCheckMirrorStatus_response @statusCodeTypeName(statusCode: 200, typeName: "RESTResponse_represents_the_response_for_a_check_request_") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 403, typeName: "RESTResponse_represents_the_response_for_a_check_request_") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = RESTResponse_represents_the_response_for_a_check_request_ | genericError

union postCheck_response @statusCodeTypeName(statusCode: 200, typeName: "RESTResponse_represents_the_response_for_a_check_request_") @statusCodeTypeName(statusCode: 400, typeName: "genericError") @statusCodeTypeName(statusCode: 500, typeName: "genericError") = RESTResponse_represents_the_response_for_a_check_request_ | genericError

scalar ObjMap

enum HTTPMethod {
  GET
  HEAD
  POST
  PUT
  DELETE
  CONNECT
  OPTIONS
  TRACE
  PATCH
}

type authQuery {
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/health/alive`\nThis endpoint returns a HTTP 200 status code when Ory Kratos is accepting incoming\nHTTP requests. This status does currently not include checks whether the database connection is working.\n\nIf the service supports TLS Edge Termination, this endpoint does not require the\n`X-Forwarded-Proto` header to be set.\n\nBe aware that if you are running multiple nodes of this service, the health status will never\nrefer to the cluster state, only to a single instance.\n"
  isAlive: isAlive_200_response @httpOperation(path: "/health/alive", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/health/ready`\nThis endpoint returns a HTTP 200 status code when Ory Kratos is up running and the environment dependencies (e.g.\nthe database) are responsive as well.\n\nIf the service supports TLS Edge Termination, this endpoint does not require the\n`X-Forwarded-Proto` header to be set.\n\nBe aware that if you are running multiple nodes of Ory Kratos, the health status will never\nrefer to the cluster state, only to a single instance.\n"
  isReady: isReady_200_response @httpOperation(path: "/health/ready", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/relation-tuples`\nGet all relation tuples that match the query. Only the namespace field is required.\n"
  getRelationTuples(
    page_token: String
    page_size: Int
    "Namespace of the Relation Tuple"
    namespace: String
    "Object of the Relation Tuple"
    object: String
    "Relation of the Relation Tuple"
    relation: String
    "SubjectID of the Relation Tuple"
    subject_id: String
    "Namespace of the Subject Set"
    subject_set_namespace: String
    "Object of the Subject Set"
    subject_set_object: String
    "Relation of the Subject Set"
    subject_set_relation: String
  ): getRelationTuples_response @httpOperation(path: "/relation-tuples", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"page_token\":\"page_token\",\"page_size\":\"page_size\",\"namespace\":\"namespace\",\"object\":\"object\",\"relation\":\"relation\",\"subject_id\":\"subject_id\",\"subject_set.namespace\":\"subject_set_namespace\",\"subject_set.object\":\"subject_set_object\",\"subject_set.relation\":\"subject_set_relation\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/relation-tuples/check`\nTo learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).\n"
  getCheckMirrorStatus: getCheckMirrorStatus_response @httpOperation(path: "/relation-tuples/check", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/relation-tuples/check/openapi`\nTo learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).\n"
  getCheck(
    "Namespace of the Relation Tuple"
    namespace: String
    "Object of the Relation Tuple"
    object: String
    "Relation of the Relation Tuple"
    relation: String
    "SubjectID of the Relation Tuple"
    subject_id: String
    "Namespace of the Subject Set"
    subject_set_namespace: String
    "Object of the Subject Set"
    subject_set_object: String
    "Relation of the Subject Set"
    subject_set_relation: String
    max_depth: Int
  ): getCheck_response @httpOperation(path: "/relation-tuples/check/openapi", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"namespace\":\"namespace\",\"object\":\"object\",\"relation\":\"relation\",\"subject_id\":\"subject_id\",\"subject_set.namespace\":\"subject_set_namespace\",\"subject_set.object\":\"subject_set_object\",\"subject_set.relation\":\"subject_set_relation\",\"max-depth\":\"max_depth\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/relation-tuples/expand`\nUse this endpoint to expand a relation tuple.\n"
  getExpand(
    "Namespace of the Subject Set"
    namespace: String!
    "Object of the Subject Set"
    object: String!
    "Relation of the Subject Set"
    relation: String!
    max_depth: Int
  ): getExpand_response @httpOperation(path: "/relation-tuples/expand", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"namespace\":\"namespace\",\"object\":\"object\",\"relation\":\"relation\",\"max-depth\":\"max_depth\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/version`\nThis endpoint returns the version of Ory Kratos.\n\nIf the service supports TLS Edge Termination, this endpoint does not require the\n`X-Forwarded-Proto` header to be set.\n\nBe aware that if you are running multiple nodes of this service, the version will never\nrefer to the cluster state, only to a single instance.\n"
  getVersion: getVersion_200_response @httpOperation(path: "/version", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/identities`\n\n"
  identityTraits: KratosIdentity @httpOperation(path: "/admin/identities", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/.well-known/ory/webauthn.js`\nThis endpoint provides JavaScript which is needed in order to perform WebAuthn login and registration.\n\nIf you are building a JavaScript Browser App (e.g. in ReactJS or AngularJS) you will need to load this file:\n\n```html\n<script src=\"https://public-kratos.example.org/.well-known/ory/webauthn.js\" type=\"script\" async />\n```\n\nMore information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).\n"
  getWebAuthnJavaScript: String @httpOperation(path: "/.well-known/ory/webauthn.js", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/courier/messages`\nLists all messages by given status and recipient.\n"
  listCourierMessages(
    "Items per Page\n\nThis is the number of items per page."
    per_page: PositiveInt = 250
    "Pagination Page\n\nThis value is currently an integer, but it is not sequential. The value is not the page number, but a\nreference. The next page can be any number and some numbers might return an empty list.\n\nFor example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist."
    page: PositiveInt = 1
    status: courierMessageStatus
    "Recipient filters out messages based on recipient.\nIf no value is provided, it doesn't take effect on filter."
    recipient: String
  ): [message] @httpOperation(path: "/admin/courier/messages", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"per_page\":\"per_page\",\"page\":\"page\",\"status\":\"status\",\"recipient\":\"recipient\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/identities`\nLists all [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model) in the system.\n"
  listIdentities(
    "Items per Page\n\nThis is the number of items per page."
    per_page: PositiveInt = 250
    "Pagination Page\n\nThis value is currently an integer, but it is not sequential. The value is not the page number, but a\nreference. The next page can be any number and some numbers might return an empty list.\n\nFor example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist."
    page: PositiveInt = 1
  ): [KratosIdentity] @httpOperation(path: "/admin/identities", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"per_page\":\"per_page\",\"page\":\"page\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/identities/{args.id}`\nReturn an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its ID. You can optionally\ninclude credentials (e.g. social sign in connections) in the response by using the `include_credential` query parameter.\n"
  getIdentity(
    "ID must be set to the ID of identity you want to get"
    id: String!
    "Include Credentials in Response\n\nCurrently, only `oidc` is supported. This will return the initial OAuth 2.0 Access,\nRefresh and (optionally) OpenID Connect ID Token."
    include_credential: [String]
  ): KratosIdentity @httpOperation(path: "/admin/identities/{args.id}", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"include_credential\":\"include_credential\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/identities/{args.id}/sessions`\nThis endpoint returns all sessions that belong to the given Identity.\n"
  listIdentitySessions(
    "ID is the identity's ID."
    id: String!
    "Items per Page\n\nThis is the number of items per page."
    per_page: PositiveInt = 250
    "Pagination Page\n\nThis value is currently an integer, but it is not sequential. The value is not the page number, but a\nreference. The next page can be any number and some numbers might return an empty list.\n\nFor example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist."
    page: PositiveInt = 1
    "Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned."
    active: Boolean
  ): [session] @httpOperation(path: "/admin/identities/{args.id}/sessions", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"per_page\":\"per_page\",\"page\":\"page\",\"active\":\"active\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/sessions`\nListing all sessions that exist.\n"
  listSessions(
    "Items per Page\n\nThis is the number of items per page to return.\nFor details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination)."
    page_size: PositiveInt = 250
    "Next Page Token\n\nThe next page token.\nFor details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination)."
    page_token: String
    "Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned."
    active: Boolean
    "ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session.\nExample - ?expand=Identity&expand=Devices\nIf no value is provided, the expandable properties are skipped."
    expand: [queryInput_listSessions_expand_items]
  ): [session] @httpOperation(path: "/admin/sessions", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"page_size\":\"page_size\",\"page_token\":\"page_token\",\"active\":\"active\",\"expand\":\"expand\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/sessions/{args.id}`\nThis endpoint is useful for:\n\nGetting a session object with all specified expandables that exist in an administrative context.\n"
  getSession(
    "ID is the session's ID."
    id: String!
    "ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session.\nExample - ?expand=Identity&expand=Devices\nIf no value is provided, the expandable properties are skipped."
    expand: [queryInput_getSession_expand_items]
  ): session @httpOperation(path: "/admin/sessions/{args.id}", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"expand\":\"expand\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/schemas`\nReturns a list of all identity schemas currently in use.\n"
  listIdentitySchemas(
    "Items per Page\n\nThis is the number of items per page."
    per_page: PositiveInt = 250
    "Pagination Page\n\nThis value is currently an integer, but it is not sequential. The value is not the page number, but a\nreference. The next page can be any number and some numbers might return an empty list.\n\nFor example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist."
    page: PositiveInt = 1
  ): [identitySchemaContainer] @httpOperation(path: "/schemas", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"per_page\":\"per_page\",\"page\":\"page\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/schemas/{args.id}`\nReturn a specific identity schema.\n"
  getIdentitySchema(
    "ID must be set to the ID of schema you want to get"
    id: String!
  ): JSON @httpOperation(path: "/schemas/{args.id}", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/errors`\nThis endpoint returns the error associated with a user-facing self service errors.\n\nThis endpoint supports stub values to help you implement the error UI:\n\n`?id=stub:500` - returns a stub 500 (Internal Server Error) error.\n\nMore information can be found at [Ory Kratos User User Facing Error Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-facing-errors).\n"
  getFlowError(
    "Error is the error's ID"
    id: String!
  ): flowError @httpOperation(path: "/self-service/errors", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"id\":\"id\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/login/api`\nThis endpoint initiates a login flow for native apps that do not use a browser, such as mobile devices, smart TVs, and so on.\n\nIf a valid provided session cookie or session token is provided, a 400 Bad Request error\nwill be returned unless the URL query parameter `?refresh=true` is set.\n\nTo fetch an existing login flow call `/self-service/login/flows?flow=<flow_id>`.\n\nYou MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server\nPages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make\nyou vulnerable to a variety of CSRF attacks, including CSRF login attacks.\n\nIn the case of an error, the `error.id` of the JSON response body can be one of:\n\n`session_already_available`: The user is already signed in.\n`session_aal1_required`: Multi-factor auth (e.g. 2fa) was requested but the user has no session yet.\n`security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.\n\nThis endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).\n\nMore information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).\n"
  createNativeLoginFlow(
    "The Session Token of the Identity performing the settings flow."
    X_Session_Token: String
    "Refresh a login session\n\nIf set to true, this will refresh an existing login session by\nasking the user to sign in again. This will reset the\nauthenticated_at time of the session."
    refresh: Boolean
    "Request a Specific AuthenticationMethod Assurance Level\n\nUse this parameter to upgrade an existing session's authenticator assurance level (AAL). This\nallows you to ask for multi-factor authentication. When an identity sign in using e.g. username+password,\nthe AAL is 1. If you wish to \"upgrade\" the session's security by asking the user to perform TOTP / WebAuth/ ...\nyou would set this to \"aal2\"."
    aal: String
  ): Login_Flow @httpOperation(path: "/self-service/login/api", operationSpecificHeaders: "{\"X-Session-Token\":\"{args.X_Session_Token}\",\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"refresh\":\"refresh\",\"aal\":\"aal\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/login/browser`\nThis endpoint initializes a browser-based user login flow. This endpoint will set the appropriate\ncookies and anti-CSRF measures required for browser-based flows.\n\nIf this endpoint is opened as a link in the browser, it will be redirected to\n`selfservice.flows.login.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session\nexists already, the browser will be redirected to `urls.default_redirect_url` unless the query parameter\n`?refresh=true` was set.\n\nIf this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the\ncase of an error, the `error.id` of the JSON response body can be one of:\n\n`session_already_available`: The user is already signed in.\n`session_aal1_required`: Multi-factor auth (e.g. 2fa) was requested but the user has no session yet.\n`security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.\n`security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!\n\nThe optional query parameter login_challenge is set when using Kratos with\nHydra in an OAuth2 flow. See the oauth2_provider.url configuration\noption.\n\nThis endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.\n\nMore information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).\n"
  createBrowserLoginFlow(
    "HTTP Cookies\n\nWhen using the SDK in a browser app, on the server side you must include the HTTP Cookie Header\nsent by the client to your server here. This ensures that CSRF and session cookies are respected."
    Cookie: String
    "Refresh a login session\n\nIf set to true, this will refresh an existing login session by\nasking the user to sign in again. This will reset the\nauthenticated_at time of the session."
    refresh: Boolean
    "Request a Specific AuthenticationMethod Assurance Level\n\nUse this parameter to upgrade an existing session's authenticator assurance level (AAL). This\nallows you to ask for multi-factor authentication. When an identity sign in using e.g. username+password,\nthe AAL is 1. If you wish to \"upgrade\" the session's security by asking the user to perform TOTP / WebAuth/ ...\nyou would set this to \"aal2\"."
    aal: String
    "The URL to return the browser to after the flow was completed."
    return_to: String
    "An optional Hydra login challenge. If present, Kratos will cooperate with\nOry Hydra to act as an OAuth2 identity provider.\n\nThe value for this parameter comes from `login_challenge` URL Query parameter sent to your\napplication (e.g. `/login?login_challenge=abcde`)."
    login_challenge: String
  ): Login_Flow @httpOperation(path: "/self-service/login/browser", operationSpecificHeaders: "{\"Cookie\":\"{args.Cookie}\",\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"refresh\":\"refresh\",\"aal\":\"aal\",\"return_to\":\"return_to\",\"login_challenge\":\"login_challenge\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/login/flows`\nThis endpoint returns a login flow's context with, for example, error details and other information.\n\nBrowser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.\nFor AJAX requests you must ensure that cookies are included in the request or requests will fail.\n\nIf you use the browser-flow for server-side apps, the services need to run on a common top-level-domain\nand you need to forward the incoming HTTP Cookie header to this endpoint:\n\n```js\npseudo-code example\nrouter.get('/login', async function (req, res) {\nconst flow = await client.getLoginFlow(req.header('cookie'), req.query['flow'])\n\nres.render('login', flow)\n})\n```\n\nThis request may fail due to several reasons. The `error.id` can be one of:\n\n`session_already_available`: The user is already signed in.\n`self_service_flow_expired`: The flow is expired and you should request a new one.\n\nMore information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).\n"
  getLoginFlow(
    "HTTP Cookies\n\nWhen using the SDK in a browser app, on the server side you must include the HTTP Cookie Header\nsent by the client to your server here. This ensures that CSRF and session cookies are respected."
    Cookie: String
    "The Login Flow ID\n\nThe value for this parameter comes from `flow` URL Query parameter sent to your\napplication (e.g. `/login?flow=abcde`)."
    id: String!
  ): Login_Flow @httpOperation(path: "/self-service/login/flows", operationSpecificHeaders: "{\"Cookie\":\"{args.Cookie}\",\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"id\":\"id\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/logout`\nThis endpoint logs out an identity in a self-service manner.\n\nIf the `Accept` HTTP header is not set to `application/json`, the browser will be redirected (HTTP 303 See Other)\nto the `return_to` parameter of the initial request or fall back to `urls.default_return_to`.\n\nIf the `Accept` HTTP header is set to `application/json`, a 204 No Content response\nwill be sent on successful logout instead.\n\nThis endpoint is NOT INTENDED for API clients and only works\nwith browsers (Chrome, Firefox, ...). For API clients you can\ncall the `/self-service/logout/api` URL directly with the Ory Session Token.\n\nMore information can be found at [Ory Kratos User Logout Documentation](https://www.ory.sh/docs/next/kratos/self-service/flows/user-logout).\n"
  updateLogoutFlow(
    "A Valid Logout Token\n\nIf you do not have a logout token because you only have a session cookie,\ncall `/self-service/logout/browser` to generate a URL for this endpoint."
    token: String
    "The URL to return to after the logout was completed."
    return_to: String
  ): Void @httpOperation(path: "/self-service/logout", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"token\":\"token\",\"return_to\":\"return_to\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/logout/browser`\nThis endpoint initializes a browser-based user logout flow and a URL which can be used to log out the user.\n\nThis endpoint is NOT INTENDED for API clients and only works\nwith browsers (Chrome, Firefox, ...). For API clients you can\ncall the `/self-service/logout/api` URL directly with the Ory Session Token.\n\nThe URL is only valid for the currently signed in user. If no user is signed in, this endpoint returns\na 401 error.\n\nWhen calling this endpoint from a backend, please ensure to properly forward the HTTP cookies.\n"
  createBrowserLogoutFlow(
    "HTTP Cookies\n\nIf you call this endpoint from a backend, please include the\noriginal Cookie header in the request."
    cookie: String
  ): logoutFlow @httpOperation(path: "/self-service/logout/browser", operationSpecificHeaders: "{\"cookie\":\"{args.cookie}\",\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/recovery/api`\nThis endpoint initiates a recovery flow for API clients such as mobile devices, smart TVs, and so on.\n\nIf a valid provided session cookie or session token is provided, a 400 Bad Request error.\n\nTo fetch an existing recovery flow call `/self-service/recovery/flows?flow=<flow_id>`.\n\nYou MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server\nPages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make\nyou vulnerable to a variety of CSRF attacks.\n\nThis endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).\n\nMore information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).\n"
  createNativeRecoveryFlow: A_Recovery_Flow @httpOperation(path: "/self-service/recovery/api", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/recovery/browser`\nThis endpoint initializes a browser-based account recovery flow. Once initialized, the browser will be redirected to\n`selfservice.flows.recovery.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session\nexists, the browser is returned to the configured return URL.\n\nIf this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects\nor a 400 bad request error if the user is already authenticated.\n\nThis endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.\n\nMore information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).\n"
  createBrowserRecoveryFlow(
    "The URL to return the browser to after the flow was completed."
    return_to: String
  ): A_Recovery_Flow @httpOperation(path: "/self-service/recovery/browser", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"return_to\":\"return_to\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/recovery/flows`\nThis endpoint returns a recovery flow's context with, for example, error details and other information.\n\nBrowser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.\nFor AJAX requests you must ensure that cookies are included in the request or requests will fail.\n\nIf you use the browser-flow for server-side apps, the services need to run on a common top-level-domain\nand you need to forward the incoming HTTP Cookie header to this endpoint:\n\n```js\npseudo-code example\nrouter.get('/recovery', async function (req, res) {\nconst flow = await client.getRecoveryFlow(req.header('Cookie'), req.query['flow'])\n\nres.render('recovery', flow)\n})\n```\n\nMore information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).\n"
  getRecoveryFlow(
    "HTTP Cookies\n\nWhen using the SDK in a browser app, on the server side you must include the HTTP Cookie Header\nsent by the client to your server here. This ensures that CSRF and session cookies are respected."
    Cookie: String
    "The Flow ID\n\nThe value for this parameter comes from `request` URL Query parameter sent to your\napplication (e.g. `/recovery?flow=abcde`)."
    id: String!
  ): A_Recovery_Flow @httpOperation(path: "/self-service/recovery/flows", operationSpecificHeaders: "{\"Cookie\":\"{args.Cookie}\",\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"id\":\"id\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/registration/api`\nThis endpoint initiates a registration flow for API clients such as mobile devices, smart TVs, and so on.\n\nIf a valid provided session cookie or session token is provided, a 400 Bad Request error\nwill be returned unless the URL query parameter `?refresh=true` is set.\n\nTo fetch an existing registration flow call `/self-service/registration/flows?flow=<flow_id>`.\n\nYou MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server\nPages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make\nyou vulnerable to a variety of CSRF attacks.\n\nIn the case of an error, the `error.id` of the JSON response body can be one of:\n\n`session_already_available`: The user is already signed in.\n`security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.\n\nThis endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).\n\nMore information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).\n"
  createNativeRegistrationFlow: registrationFlow @httpOperation(path: "/self-service/registration/api", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/registration/browser`\nThis endpoint initializes a browser-based user registration flow. This endpoint will set the appropriate\ncookies and anti-CSRF measures required for browser-based flows.\n\n:::info\n\nThis endpoint is EXPERIMENTAL and subject to potential breaking changes in the future.\n\n:::\n\nIf this endpoint is opened as a link in the browser, it will be redirected to\n`selfservice.flows.registration.ui_url` with the flow ID set as the query parameter `?flow=`. If a valid user session\nexists already, the browser will be redirected to `urls.default_redirect_url`.\n\nIf this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the\ncase of an error, the `error.id` of the JSON response body can be one of:\n\n`session_already_available`: The user is already signed in.\n`security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.\n`security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!\n\nIf this endpoint is called via an AJAX request, the response contains the registration flow without a redirect.\n\nThis endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.\n\nMore information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).\n"
  createBrowserRegistrationFlow(
    "The URL to return the browser to after the flow was completed."
    return_to: String
    "Ory OAuth 2.0 Login Challenge.\n\nIf set will cooperate with Ory OAuth2 and OpenID to act as an OAuth2 server / OpenID Provider.\n\nThe value for this parameter comes from `login_challenge` URL Query parameter sent to your\napplication (e.g. `/registration?login_challenge=abcde`).\n\nThis feature is compatible with Ory Hydra when not running on the Ory Network."
    login_challenge: String
  ): registrationFlow @httpOperation(path: "/self-service/registration/browser", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"return_to\":\"return_to\",\"login_challenge\":\"login_challenge\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/registration/flows`\nThis endpoint returns a registration flow's context with, for example, error details and other information.\n\nBrowser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.\nFor AJAX requests you must ensure that cookies are included in the request or requests will fail.\n\nIf you use the browser-flow for server-side apps, the services need to run on a common top-level-domain\nand you need to forward the incoming HTTP Cookie header to this endpoint:\n\n```js\npseudo-code example\nrouter.get('/registration', async function (req, res) {\nconst flow = await client.getRegistrationFlow(req.header('cookie'), req.query['flow'])\n\nres.render('registration', flow)\n})\n```\n\nThis request may fail due to several reasons. The `error.id` can be one of:\n\n`session_already_available`: The user is already signed in.\n`self_service_flow_expired`: The flow is expired and you should request a new one.\n\nMore information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).\n"
  getRegistrationFlow(
    "HTTP Cookies\n\nWhen using the SDK in a browser app, on the server side you must include the HTTP Cookie Header\nsent by the client to your server here. This ensures that CSRF and session cookies are respected."
    Cookie: String
    "The Registration Flow ID\n\nThe value for this parameter comes from `flow` URL Query parameter sent to your\napplication (e.g. `/registration?flow=abcde`)."
    id: String!
  ): registrationFlow @httpOperation(path: "/self-service/registration/flows", operationSpecificHeaders: "{\"Cookie\":\"{args.Cookie}\",\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"id\":\"id\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/settings/api`\nThis endpoint initiates a settings flow for API clients such as mobile devices, smart TVs, and so on.\nYou must provide a valid Ory Kratos Session Token for this endpoint to respond with HTTP 200 OK.\n\nTo fetch an existing settings flow call `/self-service/settings/flows?flow=<flow_id>`.\n\nYou MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server\nPages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make\nyou vulnerable to a variety of CSRF attacks.\n\nDepending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator\nAssurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn\ncredentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user\nto sign in with the second factor or change the configuration.\n\nIn the case of an error, the `error.id` of the JSON response body can be one of:\n\n`security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.\n`session_inactive`: No Ory Session was found - sign in a user first.\n\nThis endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).\n\nMore information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).\n"
  createNativeSettingsFlow(
    "The Session Token of the Identity performing the settings flow."
    X_Session_Token: String
  ): Flow_represents_a_Settings_Flow @httpOperation(path: "/self-service/settings/api", operationSpecificHeaders: "{\"X-Session-Token\":\"{args.X_Session_Token}\",\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/settings/browser`\nThis endpoint initializes a browser-based user settings flow. Once initialized, the browser will be redirected to\n`selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid\nOry Kratos Session Cookie is included in the request, a login flow will be initialized.\n\nIf this endpoint is opened as a link in the browser, it will be redirected to\n`selfservice.flows.settings.ui_url` with the flow ID set as the query parameter `?flow=`. If no valid user session\nwas set, the browser will be redirected to the login endpoint.\n\nIf this endpoint is called via an AJAX request, the response contains the settings flow without any redirects\nor a 401 forbidden error if no valid session was set.\n\nDepending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator\nAssurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn\ncredentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user\nto sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.\n\nIf this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the\ncase of an error, the `error.id` of the JSON response body can be one of:\n\n`security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.\n`session_inactive`: No Ory Session was found - sign in a user first.\n`security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!\n\nThis endpoint is NOT INTENDED for clients that do not have a browser (Chrome, Firefox, ...) as cookies are needed.\n\nMore information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).\n"
  createBrowserSettingsFlow(
    "HTTP Cookies\n\nWhen using the SDK in a browser app, on the server side you must include the HTTP Cookie Header\nsent by the client to your server here. This ensures that CSRF and session cookies are respected."
    Cookie: String
    "The URL to return the browser to after the flow was completed."
    return_to: String
  ): Flow_represents_a_Settings_Flow @httpOperation(path: "/self-service/settings/browser", operationSpecificHeaders: "{\"Cookie\":\"{args.Cookie}\",\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"return_to\":\"return_to\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/settings/flows`\nWhen accessing this endpoint through Ory Kratos' Public API you must ensure that either the Ory Kratos Session Cookie\nor the Ory Kratos Session Token are set.\n\nDepending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator\nAssurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn\ncredentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user\nto sign in with the second factor or change the configuration.\n\nYou can access this endpoint without credentials when using Ory Kratos' Admin API.\n\nIf this endpoint is called via an AJAX request, the response contains the flow without a redirect. In the\ncase of an error, the `error.id` of the JSON response body can be one of:\n\n`security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.\n`session_inactive`: No Ory Session was found - sign in a user first.\n`security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other\nidentity logged in instead.\n\nMore information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).\n"
  getSettingsFlow(
    "The Session Token\n\nWhen using the SDK in an app without a browser, please include the\nsession token here."
    X_Session_Token: String
    "HTTP Cookies\n\nWhen using the SDK in a browser app, on the server side you must include the HTTP Cookie Header\nsent by the client to your server here. This ensures that CSRF and session cookies are respected."
    Cookie: String
    "ID is the Settings Flow ID\n\nThe value for this parameter comes from `flow` URL Query parameter sent to your\napplication (e.g. `/settings?flow=abcde`)."
    id: String!
  ): Flow_represents_a_Settings_Flow @httpOperation(path: "/self-service/settings/flows", operationSpecificHeaders: "{\"X-Session-Token\":\"{args.X_Session_Token}\",\"Cookie\":\"{args.Cookie}\",\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"id\":\"id\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/verification/api`\nThis endpoint initiates a verification flow for API clients such as mobile devices, smart TVs, and so on.\n\nTo fetch an existing verification flow call `/self-service/verification/flows?flow=<flow_id>`.\n\nYou MUST NOT use this endpoint in client-side (Single Page Apps, ReactJS, AngularJS) nor server-side (Java Server\nPages, NodeJS, PHP, Golang, ...) browser applications. Using this endpoint in these applications will make\nyou vulnerable to a variety of CSRF attacks.\n\nThis endpoint MUST ONLY be used in scenarios such as native mobile apps (React Native, Objective C, Swift, Java, ...).\n\nMore information can be found at [Ory Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/self-service/flows/verify-email-account-activation).\n"
  createNativeVerificationFlow: A_Verification_Flow @httpOperation(path: "/self-service/verification/api", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET)
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/verification/browser`\nThis endpoint initializes a browser-based account verification flow. Once initialized, the browser will be redirected to\n`selfservice.flows.verification.ui_url` with the flow ID set as the query parameter `?flow=`.\n\nIf this endpoint is called via an AJAX request, the response contains the recovery flow without any redirects.\n\nThis endpoint is NOT INTENDED for API clients and only works with browsers (Chrome, Firefox, ...).\n\nMore information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/selfservice/flows/verify-email-account-activation).\n"
  createBrowserVerificationFlow(
    "The URL to return the browser to after the flow was completed."
    return_to: String
  ): A_Verification_Flow @httpOperation(path: "/self-service/verification/browser", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"return_to\":\"return_to\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/verification/flows`\nThis endpoint returns a verification flow's context with, for example, error details and other information.\n\nBrowser flows expect the anti-CSRF cookie to be included in the request's HTTP Cookie Header.\nFor AJAX requests you must ensure that cookies are included in the request or requests will fail.\n\nIf you use the browser-flow for server-side apps, the services need to run on a common top-level-domain\nand you need to forward the incoming HTTP Cookie header to this endpoint:\n\n```js\npseudo-code example\nrouter.get('/recovery', async function (req, res) {\nconst flow = await client.getVerificationFlow(req.header('cookie'), req.query['flow'])\n\nres.render('verification', flow)\n})\n\nMore information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/selfservice/flows/verify-email-account-activation).\n"
  getVerificationFlow(
    "HTTP Cookies\n\nWhen using the SDK on the server side you must include the HTTP Cookie Header\noriginally sent to your HTTP handler here."
    cookie: String
    "The Flow ID\n\nThe value for this parameter comes from `request` URL Query parameter sent to your\napplication (e.g. `/verification?flow=abcde`)."
    id: String!
  ): A_Verification_Flow @httpOperation(path: "/self-service/verification/flows", operationSpecificHeaders: "{\"cookie\":\"{args.cookie}\",\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"id\":\"id\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/sessions`\nThis endpoints returns all other active sessions that belong to the logged-in user.\nThe current session can be retrieved by calling the `/sessions/whoami` endpoint.\n"
  listMySessions(
    "Set the Session Token when calling from non-browser clients. A session token has a format of `MP2YWEMeM8MxjkGKpH4dqOQ4Q4DlSPaj`."
    X_Session_Token: String
    "Set the Cookie Header. This is especially useful when calling this endpoint from a server-side application. In that\nscenario you must include the HTTP Cookie Header which originally was included in the request to your server.\nAn example of a session in the HTTP Cookie Header is: `ory_kratos_session=a19iOVAbdzdgl70Rq1QZmrKmcjDtdsviCTZx7m9a9yHIUS8Wa9T7hvqyGTsLHi6Qifn2WUfpAKx9DWp0SJGleIn9vh2YF4A16id93kXFTgIgmwIOvbVAScyrx7yVl6bPZnCx27ec4WQDtaTewC1CpgudeDV2jQQnSaCP6ny3xa8qLH-QUgYqdQuoA_LF1phxgRCUfIrCLQOkolX5nv3ze_f==`.\n\nIt is ok if more than one cookie are included here as all other cookies will be ignored."
    Cookie: String
    "Items per Page\n\nThis is the number of items per page."
    per_page: PositiveInt = 250
    "Pagination Page\n\nThis value is currently an integer, but it is not sequential. The value is not the page number, but a\nreference. The next page can be any number and some numbers might return an empty list.\n\nFor example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist."
    page: PositiveInt = 1
  ): [session] @httpOperation(path: "/sessions", operationSpecificHeaders: "{\"X-Session-Token\":\"{args.X_Session_Token}\",\"Cookie\":\"{args.Cookie}\",\"accept\":\"application/json\"}", httpMethod: GET, queryParamArgMap: "{\"per_page\":\"per_page\",\"page\":\"page\"}")
  "\n>**Method**: `GET`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/sessions/whoami`\nUses the HTTP Headers in the GET request to determine (e.g. by using checking the cookies) who is authenticated.\nReturns a session object in the body or 401 if the credentials are invalid or no credentials were sent.\nWhen the request it successful it adds the user ID to the 'X-Kratos-Authenticated-Identity-Id' header\nin the response.\n\nIf you call this endpoint from a server-side application, you must forward the HTTP Cookie Header to this endpoint:\n\n```js\npseudo-code example\nrouter.get('/protected-endpoint', async function (req, res) {\nconst session = await client.toSession(undefined, req.header('cookie'))\n\nconsole.log(session)\n})\n```\n\nWhen calling this endpoint from a non-browser application (e.g. mobile app) you must include the session token:\n\n```js\npseudo-code example\n...\nconst session = await client.toSession(\"the-session-token\")\n\nconsole.log(session)\n```\n\nDepending on your configuration this endpoint might return a 403 status code if the session has a lower Authenticator\nAssurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn\ncredentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user\nto sign in with the second factor or change the configuration.\n\nThis endpoint is useful for:\n\nAJAX calls. Remember to send credentials and set up CORS correctly!\nReverse proxies and API Gateways\nServer-side calls - use the `X-Session-Token` header!\n\nThis endpoint authenticates users by checking:\n\nif the `Cookie` HTTP header was set containing an Ory Kratos Session Cookie;\nif the `Authorization: bearer <ory-session-token>` HTTP header was set with a valid Ory Kratos Session Token;\nif the `X-Session-Token` HTTP header was set with a valid Ory Kratos Session Token.\n\nIf none of these headers are set or the cooke or token are invalid, the endpoint returns a HTTP 401 status code.\n\nAs explained above, this request may fail due to several reasons. The `error.id` can be one of:\n\n`session_inactive`: No active session was found in the request (e.g. no Ory Session Cookie / Ory Session Token).\n`session_aal2_required`: An active session was found but it does not fulfil the Authenticator Assurance Level, implying that the session must (e.g.) authenticate the second factor.\n"
  toSession(
    "Set the Session Token when calling from non-browser clients. A session token has a format of `MP2YWEMeM8MxjkGKpH4dqOQ4Q4DlSPaj`."
    X_Session_Token: String
    "Set the Cookie Header. This is especially useful when calling this endpoint from a server-side application. In that\nscenario you must include the HTTP Cookie Header which originally was included in the request to your server.\nAn example of a session in the HTTP Cookie Header is: `ory_kratos_session=a19iOVAbdzdgl70Rq1QZmrKmcjDtdsviCTZx7m9a9yHIUS8Wa9T7hvqyGTsLHi6Qifn2WUfpAKx9DWp0SJGleIn9vh2YF4A16id93kXFTgIgmwIOvbVAScyrx7yVl6bPZnCx27ec4WQDtaTewC1CpgudeDV2jQQnSaCP6ny3xa8qLH-QUgYqdQuoA_LF1phxgRCUfIrCLQOkolX5nv3ze_f==`.\n\nIt is ok if more than one cookie are included here as all other cookies will be ignored."
    Cookie: String
  ): session @httpOperation(path: "/sessions/whoami", operationSpecificHeaders: "{\"X-Session-Token\":\"{args.X_Session_Token}\",\"Cookie\":\"{args.Cookie}\",\"accept\":\"application/json\"}", httpMethod: GET)
}

type authMutation {
  "\n>**Method**: `DELETE`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/admin/relation-tuples`\nUse this endpoint to delete relation tuples\n"
  deleteRelationTuples(
    "Namespace of the Relation Tuple"
    namespace: String
    "Object of the Relation Tuple"
    object: String
    "Relation of the Relation Tuple"
    relation: String
    "SubjectID of the Relation Tuple"
    subject_id: String
    "Namespace of the Subject Set"
    subject_set_namespace: String
    "Object of the Subject Set"
    subject_set_object: String
    "Relation of the Subject Set"
    subject_set_relation: String
  ): deleteRelationTuples_response @httpOperation(path: "/admin/relation-tuples", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: DELETE, queryParamArgMap: "{\"namespace\":\"namespace\",\"object\":\"object\",\"relation\":\"relation\",\"subject_id\":\"subject_id\",\"subject_set.namespace\":\"subject_set_namespace\",\"subject_set.object\":\"subject_set_object\",\"subject_set.relation\":\"subject_set_relation\"}")
  "\n>**Method**: `PATCH`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/admin/relation-tuples`\nUse this endpoint to patch one or more relation tuples.\n"
  patchRelationTuples(input: [patchDelta_Input]): patchRelationTuples_response @httpOperation(path: "/admin/relation-tuples", operationSpecificHeaders: "{\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: PATCH)
  "\n>**Method**: `PUT`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/admin/relation-tuples`\nUse this endpoint to create a relation tuple.\n"
  createRelationTuple(input: relationQuery_Input): createRelationTuple_response @httpOperation(path: "/admin/relation-tuples", operationSpecificHeaders: "{\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: PUT)
  "\n>**Method**: `POST`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/relation-tuples/check`\nTo learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).\n"
  postCheckMirrorStatus: postCheckMirrorStatus_response @httpOperation(path: "/relation-tuples/check", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: POST)
  "\n>**Method**: `POST`\n>**Base URL**: `http://localhost:4466`\n>**Path**: `/relation-tuples/check/openapi`\nTo learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).\n"
  postCheck(max_depth: Int, input: relationQuery_Input): postCheck_response @httpOperation(path: "/relation-tuples/check/openapi", operationSpecificHeaders: "{\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: POST, queryParamArgMap: "{\"max-depth\":\"max_depth\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/identities`\nCreate an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  This endpoint can also be used to\n[import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities)\nfor instance passwords, social sign in configurations or multifactor methods.\n"
  createIdentity(input: createIdentityBody_Input): KratosIdentity @httpOperation(path: "/admin/identities", operationSpecificHeaders: "{\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: POST)
  "\n>**Method**: `DELETE`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/identities/{args.id}`\nCalling this endpoint irrecoverably and permanently deletes the [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) given its ID. This action can not be undone.\nThis endpoint returns 204 when the identity was deleted or when the identity was not found, in which case it is\nassumed that is has been deleted already.\n"
  deleteIdentity(
    "ID is the identity's ID."
    id: String!
  ): Void @httpOperation(path: "/admin/identities/{args.id}", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: DELETE)
  "\n>**Method**: `PATCH`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/identities/{args.id}`\nPartially updates an [identity's](https://www.ory.sh/docs/kratos/concepts/identity-user-model) field using [JSON Patch](https://jsonpatch.com/).\nThe fields `id`, `stateChangedAt` and `credentials` can not be updated using this method.\n"
  patchIdentity(
    "ID must be set to the ID of identity you want to update"
    id: String!
    "A JSONPatchDocument request"
    input: [jsonPatch_Input]
  ): KratosIdentity @httpOperation(path: "/admin/identities/{args.id}", operationSpecificHeaders: "{\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: PATCH)
  "\n>**Method**: `PUT`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/identities/{args.id}`\nThis endpoint updates an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model). The full identity\npayload (except credentials) is expected. It is possible to update the identity's credentials as well.\n"
  updateIdentity(
    "ID must be set to the ID of identity you want to update"
    id: String!
    input: updateIdentityBody_Input
  ): KratosIdentity @httpOperation(path: "/admin/identities/{args.id}", operationSpecificHeaders: "{\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: PUT)
  "\n>**Method**: `DELETE`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/identities/{args.id}/sessions`\nCalling this endpoint irrecoverably and permanently deletes and invalidates all sessions that belong to the given Identity.\n"
  deleteIdentitySessions(
    "ID is the identity's ID."
    id: String!
  ): Void @httpOperation(path: "/admin/identities/{args.id}/sessions", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: DELETE)
  "\n>**Method**: `POST`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/recovery/code`\nThis endpoint creates a recovery code which should be given to the user in order for them to recover\n(or activate) their account.\n"
  createRecoveryCodeForIdentity(input: createRecoveryCodeForIdentityBody_Input): Recovery_Code_for_Identity @httpOperation(path: "/admin/recovery/code", operationSpecificHeaders: "{\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: POST)
  "\n>**Method**: `POST`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/recovery/link`\nThis endpoint creates a recovery link which should be given to the user in order for them to recover\n(or activate) their account.\n"
  createRecoveryLinkForIdentity(input: createRecoveryLinkForIdentityBody_Input): Identity_Recovery_Link @httpOperation(path: "/admin/recovery/link", operationSpecificHeaders: "{\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: POST)
  "\n>**Method**: `DELETE`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/sessions/{args.id}`\nCalling this endpoint deactivates the specified session. Session data is not deleted.\n"
  disableSession(
    "ID is the session's ID."
    id: String!
  ): Void @httpOperation(path: "/admin/sessions/{args.id}", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: DELETE)
  "\n>**Method**: `PATCH`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/admin/sessions/{args.id}/extend`\nCalling this endpoint extends the given session ID. If `session.earliest_possible_extend` is set it\nwill only extend the session after the specified time has passed.\n\nRetrieve the session ID from the `/sessions/whoami` endpoint / `toSession` SDK method.\n"
  extendSession(
    "ID is the session's ID."
    id: String!
  ): session @httpOperation(path: "/admin/sessions/{args.id}/extend", operationSpecificHeaders: "{\"accept\":\"application/json\"}", httpMethod: PATCH)
  "\n>**Method**: `POST`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/login`\n:::info\n\nThis endpoint is EXPERIMENTAL and subject to potential breaking changes in the future.\n\n:::\n\nUse this endpoint to complete a login flow. This endpoint\nbehaves differently for API and browser flows.\n\nAPI flows expect `application/json` to be sent in the body and responds with\nHTTP 200 and a application/json body with the session token on success;\nHTTP 410 if the original flow expired with the appropriate error messages set and optionally a `use_flow_id` parameter in the body;\nHTTP 400 on form validation errors.\n\nBrowser flows expect a Content-Type of `application/x-www-form-urlencoded` or `application/json` to be sent in the body and respond with\na HTTP 303 redirect to the post/after login URL or the `return_to` value if it was set and if the login succeeded;\na HTTP 303 redirect to the login UI URL with the flow ID containing the validation errors otherwise.\n\nBrowser flows with an accept header of `application/json` will not redirect but instead respond with\nHTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success;\nHTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set;\nHTTP 400 on form validation errors.\n\nIf this endpoint is called with `Accept: application/json` in the header, the response contains the flow without a redirect. In the\ncase of an error, the `error.id` of the JSON response body can be one of:\n\n`session_already_available`: The user is already signed in.\n`security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.\n`security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!\n`browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL.\nMost likely used in Social Sign In flows.\n\nMore information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).\n"
  updateLoginFlow(
    "The Session Token of the Identity performing the settings flow."
    X_Session_Token: String
    "HTTP Cookies\n\nWhen using the SDK in a browser app, on the server side you must include the HTTP Cookie Header\nsent by the client to your server here. This ensures that CSRF and session cookies are respected."
    Cookie: String
    "The Login Flow ID\n\nThe value for this parameter comes from `flow` URL Query parameter sent to your\napplication (e.g. `/login?flow=abcde`)."
    flow: String!
    input: updateLoginFlowBody_Input
  ): successfulNativeLogin @httpOperation(path: "/self-service/login", operationSpecificHeaders: "{\"X-Session-Token\":\"{args.X_Session_Token}\",\"Cookie\":\"{args.Cookie}\",\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: POST, queryParamArgMap: "{\"flow\":\"flow\"}")
  "\n>**Method**: `DELETE`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/logout/api`\nUse this endpoint to log out an identity using an Ory Session Token. If the Ory Session Token was successfully\nrevoked, the server returns a 204 No Content response. A 204 No Content response is also sent when\nthe Ory Session Token has been revoked already before.\n\nIf the Ory Session Token is malformed or does not exist a 403 Forbidden response will be returned.\n\nThis endpoint does not remove any HTTP\nCookies - use the Browser-Based Self-Service Logout Flow instead.\n"
  performNativeLogout(input: Perform_Native_Logout_Request_Body_Input): Void @httpOperation(path: "/self-service/logout/api", operationSpecificHeaders: "{\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: DELETE)
  "\n>**Method**: `POST`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/recovery`\nUse this endpoint to complete a recovery flow. This endpoint\nbehaves differently for API and browser flows and has several states:\n\n`choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent\nand works with API- and Browser-initiated flows.\nFor API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid.\nand a HTTP 303 See Other redirect with a fresh recovery flow if the flow was otherwise invalid (e.g. expired).\nFor Browser clients without HTTP Header `Accept` or with `Accept: text/*` it returns a HTTP 303 See Other redirect to the Recovery UI URL with the Recovery Flow ID appended.\n`sent_email` is the success state after `choose_method` for the `link` method and allows the user to request another recovery email. It\nworks for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state.\n`passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a recovery link\")\ndoes not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL\n(if the link was valid) and instructs the user to update their password, or a redirect to the Recover UI URL with\na new Recovery Flow ID which contains an error message that the recovery link was invalid.\n\nMore information can be found at [Ory Kratos Account Recovery Documentation](../self-service/flows/account-recovery).\n"
  updateRecoveryFlow(
    "HTTP Cookies\n\nWhen using the SDK in a browser app, on the server side you must include the HTTP Cookie Header\nsent by the client to your server here. This ensures that CSRF and session cookies are respected."
    Cookie: String
    "The Recovery Flow ID\n\nThe value for this parameter comes from `flow` URL Query parameter sent to your\napplication (e.g. `/recovery?flow=abcde`)."
    flow: String!
    "Recovery Token\n\nThe recovery token which completes the recovery request. If the token\nis invalid (e.g. expired) an error will be shown to the end-user.\n\nThis parameter is usually set in a link and not used by any direct API call."
    token: String
    input: updateRecoveryFlowBody_Input
  ): A_Recovery_Flow @httpOperation(path: "/self-service/recovery", operationSpecificHeaders: "{\"Cookie\":\"{args.Cookie}\",\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: POST, queryParamArgMap: "{\"flow\":\"flow\",\"token\":\"token\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/registration`\nUse this endpoint to complete a registration flow by sending an identity's traits and password. This endpoint\nbehaves differently for API and browser flows.\n\nAPI flows expect `application/json` to be sent in the body and respond with\nHTTP 200 and a application/json body with the created identity success - if the session hook is configured the\n`session` and `session_token` will also be included;\nHTTP 410 if the original flow expired with the appropriate error messages set and optionally a `use_flow_id` parameter in the body;\nHTTP 400 on form validation errors.\n\nBrowser flows expect a Content-Type of `application/x-www-form-urlencoded` or `application/json` to be sent in the body and respond with\na HTTP 303 redirect to the post/after registration URL or the `return_to` value if it was set and if the registration succeeded;\na HTTP 303 redirect to the registration UI URL with the flow ID containing the validation errors otherwise.\n\nBrowser flows with an accept header of `application/json` will not redirect but instead respond with\nHTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success;\nHTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set;\nHTTP 400 on form validation errors.\n\nIf this endpoint is called with `Accept: application/json` in the header, the response contains the flow without a redirect. In the\ncase of an error, the `error.id` of the JSON response body can be one of:\n\n`session_already_available`: The user is already signed in.\n`security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.\n`security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!\n`browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL.\nMost likely used in Social Sign In flows.\n\nMore information can be found at [Ory Kratos User Login](https://www.ory.sh/docs/kratos/self-service/flows/user-login) and [User Registration Documentation](https://www.ory.sh/docs/kratos/self-service/flows/user-registration).\n"
  updateRegistrationFlow(
    "HTTP Cookies\n\nWhen using the SDK in a browser app, on the server side you must include the HTTP Cookie Header\nsent by the client to your server here. This ensures that CSRF and session cookies are respected."
    Cookie: String
    "The Registration Flow ID\n\nThe value for this parameter comes from `flow` URL Query parameter sent to your\napplication (e.g. `/registration?flow=abcde`)."
    flow: String!
    input: updateRegistrationFlowBody_Input
  ): successfulNativeRegistration @httpOperation(path: "/self-service/registration", operationSpecificHeaders: "{\"Cookie\":\"{args.Cookie}\",\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: POST, queryParamArgMap: "{\"flow\":\"flow\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/settings`\nUse this endpoint to complete a settings flow by sending an identity's updated password. This endpoint\nbehaves differently for API and browser flows.\n\nAPI-initiated flows expect `application/json` to be sent in the body and respond with\nHTTP 200 and an application/json body with the session token on success;\nHTTP 303 redirect to a fresh settings flow if the original flow expired with the appropriate error messages set;\nHTTP 400 on form validation errors.\nHTTP 401 when the endpoint is called without a valid session token.\nHTTP 403 when `selfservice.flows.settings.privileged_session_max_age` was reached or the session's AAL is too low.\nImplies that the user needs to re-authenticate.\n\nBrowser flows without HTTP Header `Accept` or with `Accept: text/*` respond with\na HTTP 303 redirect to the post/after settings URL or the `return_to` value if it was set and if the flow succeeded;\na HTTP 303 redirect to the Settings UI URL with the flow ID containing the validation errors otherwise.\na HTTP 303 redirect to the login endpoint when `selfservice.flows.settings.privileged_session_max_age` was reached or the session's AAL is too low.\n\nBrowser flows with HTTP Header `Accept: application/json` respond with\nHTTP 200 and a application/json body with the signed in identity and a `Set-Cookie` header on success;\nHTTP 303 redirect to a fresh login flow if the original flow expired with the appropriate error messages set;\nHTTP 401 when the endpoint is called without a valid session cookie.\nHTTP 403 when the page is accessed without a session cookie or the session's AAL is too low.\nHTTP 400 on form validation errors.\n\nDepending on your configuration this endpoint might return a 403 error if the session has a lower Authenticator\nAssurance Level (AAL) than is possible for the identity. This can happen if the identity has password + webauthn\ncredentials (which would result in AAL2) but the session has only AAL1. If this error occurs, ask the user\nto sign in with the second factor (happens automatically for server-side browser flows) or change the configuration.\n\nIf this endpoint is called with a `Accept: application/json` HTTP header, the response contains the flow without a redirect. In the\ncase of an error, the `error.id` of the JSON response body can be one of:\n\n`session_refresh_required`: The identity requested to change something that needs a privileged session. Redirect\nthe identity to the login init endpoint with query parameters `?refresh=true&return_to=<the-current-browser-url>`,\nor initiate a refresh login flow otherwise.\n`security_csrf_violation`: Unable to fetch the flow because a CSRF violation occurred.\n`session_inactive`: No Ory Session was found - sign in a user first.\n`security_identity_mismatch`: The flow was interrupted with `session_refresh_required` but apparently some other\nidentity logged in instead.\n`security_identity_mismatch`: The requested `?return_to` address is not allowed to be used. Adjust this in the configuration!\n`browser_location_change_required`: Usually sent when an AJAX request indicates that the browser needs to open a specific URL.\nMost likely used in Social Sign In flows.\n\nMore information can be found at [Ory Kratos User Settings & Profile Management Documentation](../self-service/flows/user-settings).\n"
  updateSettingsFlow(
    "The Session Token of the Identity performing the settings flow."
    X_Session_Token: String
    "HTTP Cookies\n\nWhen using the SDK in a browser app, on the server side you must include the HTTP Cookie Header\nsent by the client to your server here. This ensures that CSRF and session cookies are respected."
    Cookie: String
    "The Settings Flow ID\n\nThe value for this parameter comes from `flow` URL Query parameter sent to your\napplication (e.g. `/settings?flow=abcde`)."
    flow: String!
    input: updateSettingsFlowBody_Input
  ): Flow_represents_a_Settings_Flow @httpOperation(path: "/self-service/settings", operationSpecificHeaders: "{\"X-Session-Token\":\"{args.X_Session_Token}\",\"Cookie\":\"{args.Cookie}\",\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: POST, queryParamArgMap: "{\"flow\":\"flow\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/self-service/verification`\nUse this endpoint to complete a verification flow. This endpoint\nbehaves differently for API and browser flows and has several states:\n\n`choose_method` expects `flow` (in the URL query) and `email` (in the body) to be sent\nand works with API- and Browser-initiated flows.\nFor API clients and Browser clients with HTTP Header `Accept: application/json` it either returns a HTTP 200 OK when the form is valid and HTTP 400 OK when the form is invalid\nand a HTTP 303 See Other redirect with a fresh verification flow if the flow was otherwise invalid (e.g. expired).\nFor Browser clients without HTTP Header `Accept` or with `Accept: text/*` it returns a HTTP 303 See Other redirect to the Verification UI URL with the Verification Flow ID appended.\n`sent_email` is the success state after `choose_method` when using the `link` method and allows the user to request another verification email. It\nworks for both API and Browser-initiated flows and returns the same responses as the flow in `choose_method` state.\n`passed_challenge` expects a `token` to be sent in the URL query and given the nature of the flow (\"sending a verification link\")\ndoes not have any API capabilities. The server responds with a HTTP 303 See Other redirect either to the Settings UI URL\n(if the link was valid) and instructs the user to update their password, or a redirect to the Verification UI URL with\na new Verification Flow ID which contains an error message that the verification link was invalid.\n\nMore information can be found at [Ory Kratos Email and Phone Verification Documentation](https://www.ory.sh/docs/kratos/selfservice/flows/verify-email-account-activation).\n"
  updateVerificationFlow(
    "HTTP Cookies\n\nWhen using the SDK in a browser app, on the server side you must include the HTTP Cookie Header\nsent by the client to your server here. This ensures that CSRF and session cookies are respected."
    Cookie: String
    "The Verification Flow ID\n\nThe value for this parameter comes from `flow` URL Query parameter sent to your\napplication (e.g. `/verification?flow=abcde`)."
    flow: String!
    "Verification Token\n\nThe verification token which completes the verification request. If the token\nis invalid (e.g. expired) an error will be shown to the end-user.\n\nThis parameter is usually set in a link and not used by any direct API call."
    token: String
    input: updateVerificationFlowWithLinkMethod_Input
  ): A_Verification_Flow @httpOperation(path: "/self-service/verification", operationSpecificHeaders: "{\"Cookie\":\"{args.Cookie}\",\"Content-Type\":\"application/json\",\"accept\":\"application/json\"}", httpMethod: POST, queryParamArgMap: "{\"flow\":\"flow\",\"token\":\"token\"}")
  "\n>**Method**: `DELETE`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/sessions`\nCalling this endpoint invalidates all except the current session that belong to the logged-in user.\nSession data are not deleted.\n"
  disableMyOtherSessions(
    "Set the Session Token when calling from non-browser clients. A session token has a format of `MP2YWEMeM8MxjkGKpH4dqOQ4Q4DlSPaj`."
    X_Session_Token: String
    "Set the Cookie Header. This is especially useful when calling this endpoint from a server-side application. In that\nscenario you must include the HTTP Cookie Header which originally was included in the request to your server.\nAn example of a session in the HTTP Cookie Header is: `ory_kratos_session=a19iOVAbdzdgl70Rq1QZmrKmcjDtdsviCTZx7m9a9yHIUS8Wa9T7hvqyGTsLHi6Qifn2WUfpAKx9DWp0SJGleIn9vh2YF4A16id93kXFTgIgmwIOvbVAScyrx7yVl6bPZnCx27ec4WQDtaTewC1CpgudeDV2jQQnSaCP6ny3xa8qLH-QUgYqdQuoA_LF1phxgRCUfIrCLQOkolX5nv3ze_f==`.\n\nIt is ok if more than one cookie are included here as all other cookies will be ignored."
    Cookie: String
  ): deleteMySessionsCount @httpOperation(path: "/sessions", operationSpecificHeaders: "{\"X-Session-Token\":\"{args.X_Session_Token}\",\"Cookie\":\"{args.Cookie}\",\"accept\":\"application/json\"}", httpMethod: DELETE)
  "\n>**Method**: `DELETE`\n>**Base URL**: `http://localhost:4434`\n>**Path**: `/sessions/{args.id}`\nCalling this endpoint invalidates the specified session. The current session cannot be revoked.\nSession data are not deleted.\n"
  disableMySession(
    "Set the Session Token when calling from non-browser clients. A session token has a format of `MP2YWEMeM8MxjkGKpH4dqOQ4Q4DlSPaj`."
    X_Session_Token: String
    "Set the Cookie Header. This is especially useful when calling this endpoint from a server-side application. In that\nscenario you must include the HTTP Cookie Header which originally was included in the request to your server.\nAn example of a session in the HTTP Cookie Header is: `ory_kratos_session=a19iOVAbdzdgl70Rq1QZmrKmcjDtdsviCTZx7m9a9yHIUS8Wa9T7hvqyGTsLHi6Qifn2WUfpAKx9DWp0SJGleIn9vh2YF4A16id93kXFTgIgmwIOvbVAScyrx7yVl6bPZnCx27ec4WQDtaTewC1CpgudeDV2jQQnSaCP6ny3xa8qLH-QUgYqdQuoA_LF1phxgRCUfIrCLQOkolX5nv3ze_f==`.\n\nIt is ok if more than one cookie are included here as all other cookies will be ignored."
    Cookie: String
    "ID is the session's ID."
    id: String!
  ): Void @httpOperation(path: "/sessions/{args.id}", operationSpecificHeaders: "{\"X-Session-Token\":\"{args.X_Session_Token}\",\"Cookie\":\"{args.Cookie}\",\"accept\":\"application/json\"}", httpMethod: DELETE)
}

type hoursMutation {
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/add-client`\n\n"
  addClient(name: String!): JSON @httpOperation(path: "/add-client", httpMethod: POST, queryParamArgMap: "{\"name\":\"name\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/remove-client`\n\n"
  removeClient(id: String!): JSON @httpOperation(path: "/remove-client", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/rename-client`\n\n"
  renameClient(id: String!, name: String!): JSON @httpOperation(path: "/rename-client", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\",\"name\":\"name\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/start-entry`\n\n"
  startEntry: JSON @httpOperation(path: "/start-entry", httpMethod: POST)
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/stop-entry`\n\n"
  stopEntry(id: String!): JSON @httpOperation(path: "/stop-entry", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/remove-entry`\n\n"
  removeEntry(id: String!): JSON @httpOperation(path: "/remove-entry", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/set-entry-start`\n\n"
  setEntryStart(id: String!, start: String!): JSON @httpOperation(path: "/set-entry-start", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\",\"start\":\"start\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/set-entry-description`\n\n"
  setEntryDescription(id: String!, description: String!): JSON @httpOperation(path: "/set-entry-description", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\",\"description\":\"description\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/set-entry-duration`\n\n"
  setEntryDuration(id: String!, duration: String!): JSON @httpOperation(path: "/set-entry-duration", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\",\"duration\":\"duration\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/set-entry-project`\n\n"
  setEntryProject(id: String!, projectId: String!): JSON @httpOperation(path: "/set-entry-project", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\",\"projectId\":\"projectId\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/add-entry-tag`\n\n"
  addEntryTag(id: String!, tagId: String!): JSON @httpOperation(path: "/add-entry-tag", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\",\"tagId\":\"tagId\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/remove-entry-tag`\n\n"
  removeEntryTag(id: String!, tagId: String!): JSON @httpOperation(path: "/remove-entry-tag", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\",\"tagId\":\"tagId\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/add-project`\n\n"
  addProject(name: String!): JSON @httpOperation(path: "/add-project", httpMethod: POST, queryParamArgMap: "{\"name\":\"name\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/remove-project`\n\n"
  removeProject(id: String!): JSON @httpOperation(path: "/remove-project", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/rename-project`\n\n"
  renameProject(id: String!, name: String!): JSON @httpOperation(path: "/rename-project", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\",\"name\":\"name\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/set-project-client`\n\n"
  setProjectClient(id: String!, clientId: String!): JSON @httpOperation(path: "/set-project-client", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\",\"clientId\":\"clientId\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/add-tag`\n\n"
  addTag(name: String!): JSON @httpOperation(path: "/add-tag", httpMethod: POST, queryParamArgMap: "{\"name\":\"name\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/remove-tag`\n\n"
  removeTag(id: String!): JSON @httpOperation(path: "/remove-tag", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\"}")
  "\n>**Method**: `POST`\n>**Base URL**: `http://127.0.0.1:3000`\n>**Path**: `/rename-tag`\n\n"
  renameTag(id: String!, name: String!): JSON @httpOperation(path: "/rename-tag", httpMethod: POST, queryParamArgMap: "{\"id\":\"id\",\"name\":\"name\"}")
}

"An [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) represents a (human) user in Ory."
type KratosIdentity {
  traits: query_identityTraits_traits
  "CreatedAt is a helper struct field for gobuffalo.pop."
  created_at: DateTime
  credentials: query_listIdentities_items_credentials
  "ID is the identity's unique identifier.\n\nThe Identity ID can not be changed and can not be chosen. This ensures future\ncompatibility and optimization for distributed stores such as CockroachDB."
  id: UUID!
  "NullJSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger and is NULLable-"
  metadata_admin: String
  "NullJSONRawMessage represents a json.RawMessage that works well with JSON, SQL, and Swagger and is NULLable-"
  metadata_public: String
  "RecoveryAddresses contains all the addresses that can be used to recover an identity."
  recovery_addresses: [recoveryIdentityAddress]
  "SchemaID is the ID of the JSON Schema to be used for validating the identity's traits."
  schema_id: String!
  "SchemaURL is the URL of the endpoint where the identity's traits schema can be fetched from.\n\nformat: url"
  schema_url: String!
  state: An_Identity_SINGLE_QUOTE_s_State
  state_changed_at: DateTime
  "UpdatedAt is a helper struct field for gobuffalo.pop."
  updated_at: DateTime
  "VerifiableAddresses contains all the addresses that can be verified by the user."
  verifiable_addresses: [verifiableIdentityAddress]
}

type query_identityTraits_traits {
  email: EmailAddress!
  name: query_identityTraits_traits_name
  additionalProperties: JSON @resolveRoot
}

"A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/."
scalar EmailAddress @specifiedBy(url: "https://www.w3.org/Protocols/rfc822/")

type query_identityTraits_traits_name {
  first: String
  last: String
}

type message {
  body: String
  "CreatedAt is a helper struct field for gobuffalo.pop."
  created_at: DateTime
  id: UUID
  recipient: String
  send_count: Int
  status: courierMessageStatus
  subject: String
  template_type: query_listCourierMessages_items_template_type
  type: A_Message_SINGLE_QUOTE_s_Type
  "UpdatedAt is a helper struct field for gobuffalo.pop."
  updated_at: DateTime
}

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime

"A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier."
scalar UUID

"A Message's Status"
enum courierMessageStatus {
  queued
  sent
  processing
  abandoned
}

enum query_listCourierMessages_items_template_type {
  recovery_invalid
  recovery_valid
  recovery_code_invalid
  recovery_code_valid
  verification_invalid
  verification_valid
  verification_code_invalid
  verification_code_valid
  otp
  stub
}

"It can either be `email` or `phone`"
enum A_Message_SINGLE_QUOTE_s_Type {
  email
  phone
}

"Integers that will have a value greater than 0."
scalar PositiveInt

"Credentials represents all credentials that can be used for authenticating this identity."
type query_listIdentities_items_credentials {
  additionalProperties: [identityCredentials_entry] @dictionary
}

type identityCredentials_entry {
  key: ID!
  value: identityCredentials
}

"Credentials represents a specific credential type"
type identityCredentials {
  config: JSON
  "CreatedAt is a helper struct field for gobuffalo.pop."
  created_at: DateTime
  "Identifiers represents a list of unique identifiers this credential type matches."
  identifiers: [String]
  type: CredentialsType__represents_several_different_credential_types_COMMA__like_password_credentials_COMMA__passwordless_credentials_COMMA_
  "UpdatedAt is a helper struct field for gobuffalo.pop."
  updated_at: DateTime
  "Version refers to the version of the credential. Useful when changing the config schema."
  version: Int
}

"and so on."
enum CredentialsType__represents_several_different_credential_types_COMMA__like_password_credentials_COMMA__passwordless_credentials_COMMA_ {
  password
  totp
  oidc
  webauthn
  lookup_secret
}

type recoveryIdentityAddress {
  "CreatedAt is a helper struct field for gobuffalo.pop."
  created_at: DateTime
  id: UUID!
  "UpdatedAt is a helper struct field for gobuffalo.pop."
  updated_at: DateTime
  value: String!
  via: String!
}

"The state can either be `active` or `inactive`."
enum An_Identity_SINGLE_QUOTE_s_State {
  active
  inactive
}

"VerifiableAddress is an identity's verifiable address"
type verifiableIdentityAddress {
  "When this entry was created"
  created_at: DateTime
  "The ID"
  id: UUID
  "VerifiableAddressStatus must not exceed 16 characters as that is the limitation in the SQL Schema"
  status: String!
  "When this entry was last updated"
  updated_at: DateTime
  "The address value\n\nexample foo@user.com"
  value: String!
  "Indicates if the address has already been verified"
  verified: Boolean!
  verified_at: DateTime
  "VerifiableAddressType must not exceed 16 characters as that is the limitation in the SQL Schema"
  via: String!
}

"A Session"
type session {
  "Active state. If false the session is no longer active."
  active: Boolean
  "The Session Authentication Timestamp\n\nWhen this session was authenticated at. If multi-factor authentication was used this\nis the time when the last factor was authenticated (e.g. the TOTP code challenge was completed)."
  authenticated_at: DateTime
  "A list of authenticators which were used to authenticate the session."
  authentication_methods: [AuthenticationMethod_identifies_an_authentication_method]
  authenticator_assurance_level: Authenticator_Assurance_Level_AAL
  "Devices has history of all endpoints where the session was used"
  devices: [sessionDevice]
  "The Session Expiry\n\nWhen this session expires at."
  expires_at: DateTime
  "Session ID"
  id: UUID!
  identity: KratosIdentity!
  "The Session Issuance Timestamp\n\nWhen this session was issued at. Usually equal or close to `authenticated_at`."
  issued_at: DateTime
}

"A singular authenticator used during authentication / login."
type AuthenticationMethod_identifies_an_authentication_method {
  aal: Authenticator_Assurance_Level_AAL
  "When the authentication challenge was completed."
  completed_at: DateTime
  method: The_method_used
}

"The authenticator assurance level can be one of \"aal1\", \"aal2\", or \"aal3\". A higher number means that it is harder\nfor an attacker to compromise the account.\n\nGenerally, \"aal1\" implies that one authentication factor was used while AAL2 implies that two factors (e.g.\npassword + TOTP) have been used.\n\nTo learn more about these levels please head over to: https://www.ory.sh/kratos/docs/concepts/credentials"
enum Authenticator_Assurance_Level_AAL {
  aal0
  aal1
  aal2
  aal3
}

enum The_method_used {
  link_recovery
  code_recovery
  password
  totp
  oidc
  webauthn
  lookup_secret
  v0_6_legacy_session @enum(value: "\"v0.6_legacy_session\"")
}

"Device corresponding to a Session"
type sessionDevice {
  "Device record ID"
  id: UUID!
  "IPAddress of the client"
  ip_address: String
  "Geo Location corresponding to the IP Address"
  location: String
  "UserAgent of the client"
  user_agent: String
}

enum queryInput_listSessions_expand_items {
  Devices
  Identity
}

enum queryInput_getSession_expand_items {
  Devices
  Identity
}

"An Identity JSON Schema Container"
type identitySchemaContainer {
  "The ID of the Identity JSON Schema"
  id: String
  schema: JSON
}

type flowError {
  "CreatedAt is a helper struct field for gobuffalo.pop."
  created_at: DateTime
  error: JSON
  "ID of the error container."
  id: UUID!
  "UpdatedAt is a helper struct field for gobuffalo.pop."
  updated_at: DateTime
}

"This object represents a login flow. A login flow is initiated at the \"Initiate Login API / Browser Flow\"\nendpoint by a client.\n\nOnce a login flow is completed successfully, a session cookie or session token will be issued."
type Login_Flow {
  active: CredentialsType__represents_several_different_credential_types_COMMA__like_password_credentials_COMMA__passwordless_credentials_COMMA_
  "CreatedAt is a helper struct field for gobuffalo.pop."
  created_at: DateTime
  "ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in,\na new flow has to be initiated."
  expires_at: DateTime!
  "ID represents the flow's unique ID. When performing the login flow, this\nrepresents the id in the login UI's query parameter: http://<selfservice.flows.login.ui_url>/?flow=<flow_id>"
  id: UUID!
  "IssuedAt is the time (UTC) when the flow started."
  issued_at: DateTime!
  oauth2_login_challenge: String
  oauth2_login_request: OAuth2LoginRequest
  "Refresh stores whether this login flow should enforce re-authentication."
  refresh: Boolean
  "RequestURL is the initial URL that was requested from Ory Kratos. It can be used\nto forward information contained in the URL's path or query for example."
  request_url: String!
  requested_aal: Authenticator_Assurance_Level_AAL
  "ReturnTo contains the requested return_to URL."
  return_to: String
  "The flow type can either be `api` or `browser`."
  type: String!
  ui: uiContainer!
  "UpdatedAt is a helper struct field for gobuffalo.pop."
  updated_at: DateTime
}

"OAuth2LoginRequest struct for OAuth2LoginRequest"
type OAuth2LoginRequest {
  "ID is the identifier (\\\"login challenge\\\") of the login request. It is used to identify the session."
  challenge: String
  client: OAuth2Client_OAuth_2_0_Clients_are_used_to_perform_OAuth_2_0_and_OpenID_Connect_flows__Usually_COMMA__OAuth_2_0_clients_are_generated_for_applications_which_want_to_consume_your_OAuth_2_0_or_OpenID_Connect_capabilities_
  oidc_context: OAuth2ConsentRequestOpenIDConnectContext
  "RequestURL is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client. It is the URL which initiates the OAuth 2.0 Authorization Code or OAuth 2.0 Implicit flow. This URL is typically not needed, but might come in handy if you want to deal with additional request parameters."
  request_url: String
  requested_access_token_audience: [String]
  requested_scope: [String]
  "SessionID is the login session ID. If the user-agent reuses a login session (via cookie / remember flag) this ID will remain the same. If the user-agent did not have an existing authentication session (e.g. remember is false) this will be a new random value. This value is used as the \\\"sid\\\" parameter in the ID Token and in OIDC Front-/Back- channel logout. It's value can generally be used to associate consecutive login requests by a certain user."
  session_id: String
  "Skip, if true, implies that the client has requested the same scopes from the same user previously. If true, you can skip asking the user to grant the requested scopes, and simply forward the user to the redirect URL.  This feature allows you to update / set session information."
  skip: Boolean
  "Subject is the user ID of the end-user that authenticated. Now, that end user needs to grant or deny the scope requested by the OAuth 2.0 client. If this value is set and `skip` is true, you MUST include this subject type when accepting the login request, or the request will fail."
  subject: String
}

type OAuth2Client_OAuth_2_0_Clients_are_used_to_perform_OAuth_2_0_and_OpenID_Connect_flows__Usually_COMMA__OAuth_2_0_clients_are_generated_for_applications_which_want_to_consume_your_OAuth_2_0_or_OpenID_Connect_capabilities_ {
  allowed_cors_origins: [String]
  audience: [String]
  "Specify a time duration in milliseconds, seconds, minutes, hours."
  authorization_code_grant_access_token_lifespan: String
  "Specify a time duration in milliseconds, seconds, minutes, hours."
  authorization_code_grant_id_token_lifespan: String
  "Specify a time duration in milliseconds, seconds, minutes, hours."
  authorization_code_grant_refresh_token_lifespan: String
  "OpenID Connect Back-Channel Logout Session Required  Boolean value specifying whether the RP requires that a sid (session ID) Claim be included in the Logout Token to identify the RP session with the OP when the backchannel_logout_uri is used. If omitted, the default value is false."
  backchannel_logout_session_required: Boolean
  "OpenID Connect Back-Channel Logout URI  RP URL that will cause the RP to log itself out when sent a Logout Token by the OP."
  backchannel_logout_uri: String
  "Specify a time duration in milliseconds, seconds, minutes, hours."
  client_credentials_grant_access_token_lifespan: String
  "OAuth 2.0 Client ID  The ID is autogenerated and immutable."
  client_id: String
  "OAuth 2.0 Client Name  The human-readable name of the client to be presented to the end-user during authorization."
  client_name: String
  "OAuth 2.0 Client Secret  The secret will be included in the create request as cleartext, and then never again. The secret is kept in hashed format and is not recoverable once lost."
  client_secret: String
  "OAuth 2.0 Client Secret Expires At  The field is currently not supported and its value is always 0."
  client_secret_expires_at: Int
  "OAuth 2.0 Client URI  ClientURI is a URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion."
  client_uri: String
  contacts: [String]
  "OAuth 2.0 Client Creation Date  CreatedAt returns the timestamp of the client's creation."
  created_at: DateTime
  "OpenID Connect Front-Channel Logout Session Required  Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters be included to identify the RP session with the OP when the frontchannel_logout_uri is used. If omitted, the default value is false."
  frontchannel_logout_session_required: Boolean
  "OpenID Connect Front-Channel Logout URI  RP URL that will cause the RP to log itself out when rendered in an iframe by the OP. An iss (issuer) query parameter and a sid (session ID) query parameter MAY be included by the OP to enable the RP to validate the request and to determine which of the potentially multiple sessions is to be logged out; if either is included, both MUST be."
  frontchannel_logout_uri: String
  grant_types: [String]
  "Specify a time duration in milliseconds, seconds, minutes, hours."
  implicit_grant_access_token_lifespan: String
  "Specify a time duration in milliseconds, seconds, minutes, hours."
  implicit_grant_id_token_lifespan: String
  "OAuth 2.0 Client JSON Web Key Set  Client's JSON Web Key Set [JWK] document, passed by value. The semantics of the jwks parameter are the same as the jwks_uri parameter, other than that the JWK Set is passed by value, rather than by reference. This parameter is intended only to be used by Clients that, for some reason, are unable to use the jwks_uri parameter, for instance, by native applications that might not have a location to host the contents of the JWK Set. If a Client can use jwks_uri, it MUST NOT use jwks. One significant downside of jwks is that it does not enable key rotation (which jwks_uri does, as described in Section 10 of OpenID Connect Core 1.0 [OpenID.Core]). The jwks_uri and jwks parameters MUST NOT be used together."
  jwks: JSON
  "OAuth 2.0 Client JSON Web Key Set URL  URL for the Client's JSON Web Key Set [JWK] document. If the Client signs requests to the Server, it contains the signing key(s) the Server uses to validate signatures from the Client. The JWK Set MAY also contain the Client's encryption keys(s), which are used by the Server to encrypt responses to the Client. When both signing and encryption keys are made available, a use (Key Use) parameter value is REQUIRED for all keys in the referenced JWK Set to indicate each key's intended usage. Although some algorithms allow the same key to be used for both signatures and encryption, doing so is NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used to provide X.509 representations of keys provided. When used, the bare key values MUST still be present and MUST match those in the certificate."
  jwks_uri: String
  "Specify a time duration in milliseconds, seconds, minutes, hours."
  jwt_bearer_grant_access_token_lifespan: String
  "OAuth 2.0 Client Logo URI  A URL string referencing the client's logo."
  logo_uri: String
  metadata: JSON
  "OAuth 2.0 Client Owner  Owner is a string identifying the owner of the OAuth 2.0 Client."
  owner: String
  "OAuth 2.0 Client Policy URI  PolicyURI is a URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data."
  policy_uri: String
  post_logout_redirect_uris: [String]
  redirect_uris: [String]
  "Specify a time duration in milliseconds, seconds, minutes, hours."
  refresh_token_grant_access_token_lifespan: String
  "Specify a time duration in milliseconds, seconds, minutes, hours."
  refresh_token_grant_id_token_lifespan: String
  "Specify a time duration in milliseconds, seconds, minutes, hours."
  refresh_token_grant_refresh_token_lifespan: String
  "OpenID Connect Dynamic Client Registration Access Token  RegistrationAccessToken can be used to update, get, or delete the OAuth2 Client. It is sent when creating a client using Dynamic Client Registration."
  registration_access_token: String
  "OpenID Connect Dynamic Client Registration URL  RegistrationClientURI is the URL used to update, get, or delete the OAuth2 Client."
  registration_client_uri: String
  "OpenID Connect Request Object Signing Algorithm  JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP. All Request Objects from this Client MUST be rejected, if not signed with this algorithm."
  request_object_signing_alg: String
  request_uris: [String]
  response_types: [String]
  "OAuth 2.0 Client Scope  Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens."
  scope: String
  "OpenID Connect Sector Identifier URI  URL using the https scheme to be used in calculating Pseudonymous Identifiers by the OP. The URL references a file with a single JSON array of redirect_uri values."
  sector_identifier_uri: String
  "OpenID Connect Subject Type  The `subject_types_supported` Discovery parameter contains a list of the supported subject_type values for this server. Valid types include `pairwise` and `public`."
  subject_type: String
  "OAuth 2.0 Token Endpoint Authentication Method  Requested Client Authentication method for the Token Endpoint. The options are:  `client_secret_post`: (default) Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` in the HTTP body. `client_secret_basic`: Send `client_id` and `client_secret` as `application/x-www-form-urlencoded` encoded in the HTTP Authorization header. `private_key_jwt`: Use JSON Web Tokens to authenticate the client. `none`: Used for public clients (native apps, mobile apps) which can not have secrets."
  token_endpoint_auth_method: String
  "OAuth 2.0 Token Endpoint Signing Algorithm  Requested Client Authentication signing algorithm for the Token Endpoint."
  token_endpoint_auth_signing_alg: String
  "OAuth 2.0 Client Terms of Service URI  A URL string pointing to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client."
  tos_uri: String
  "OAuth 2.0 Client Last Update Date  UpdatedAt returns the timestamp of the last update."
  updated_at: DateTime
  "OpenID Connect Request Userinfo Signed Response Algorithm  JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. If this is specified, the response will be JWT [JWT] serialized, and signed using JWS. The default, if omitted, is for the UserInfo Response to return the Claims as a UTF-8 encoded JSON object using the application/json content-type."
  userinfo_signed_response_alg: String
}

"OAuth2ConsentRequestOpenIDConnectContext struct for OAuth2ConsentRequestOpenIDConnectContext"
type OAuth2ConsentRequestOpenIDConnectContext {
  "ACRValues is the Authentication AuthorizationContext Class Reference requested in the OAuth 2.0 Authorization request. It is a parameter defined by OpenID Connect and expresses which level of authentication (e.g. 2FA) is required.  OpenID Connect defines it as follows: > Requested Authentication AuthorizationContext Class Reference values. Space-separated string that specifies the acr values that the Authorization Server is being requested to use for processing this Authentication Request, with the values appearing in order of preference. The Authentication AuthorizationContext Class satisfied by the authentication performed is returned as the acr Claim Value, as specified in Section 2. The acr Claim is requested as a Voluntary Claim by this parameter."
  acr_values: [String]
  "Display is a string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User. The defined values are: page: The Authorization Server SHOULD display the authentication and consent UI consistent with a full User Agent page view. If the display parameter is not specified, this is the default display mode. popup: The Authorization Server SHOULD display the authentication and consent UI consistent with a popup User Agent window. The popup User Agent window should be of an appropriate size for a login-focused dialog and should not obscure the entire window that it is popping up over. touch: The Authorization Server SHOULD display the authentication and consent UI consistent with a device that leverages a touch interface. wap: The Authorization Server SHOULD display the authentication and consent UI consistent with a \\\"feature phone\\\" type display.  The Authorization Server MAY also attempt to detect the capabilities of the User Agent and present an appropriate display."
  display: String
  "IDTokenHintClaims are the claims of the ID Token previously issued by the Authorization Server being passed as a hint about the End-User's current or past authenticated session with the Client."
  id_token_hint_claims: JSON
  "LoginHint hints about the login identifier the End-User might use to log in (if necessary). This hint can be used by an RP if it first asks the End-User for their e-mail address (or other identifier) and then wants to pass that value as a hint to the discovered authorization service. This value MAY also be a phone number in the format specified for the phone_number Claim. The use of this parameter is optional."
  login_hint: String
  "UILocales is the End-User'id preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 [RFC5646] language tag values, ordered by preference. For instance, the value \\\"fr-CA fr en\\\" represents a preference for French as spoken in Canada, then French (without a region designation), followed by English (without a region designation). An error SHOULD NOT result if some or all of the requested locales are not supported by the OpenID Provider."
  ui_locales: [String]
}

"Container represents a HTML Form. The container can work with both HTTP Form and JSON requests"
type uiContainer {
  "Action should be used as the form action URL `<form action=\"{{ .Action }}\" method=\"post\">`."
  action: String!
  messages: [uiText]
  "Method is the form method (e.g. POST)"
  method: String!
  nodes: [Node_represents_a_flow_SINGLE_QUOTE_s_nodes]!
}

type uiText {
  context: JSON
  id: Int!
  "The message text. Written in american english."
  text: String!
  type: query_createNativeLoginFlow_ui_messages_items_type!
}

"The message type.\ninfo Info\nerror Error\nsuccess Success"
enum query_createNativeLoginFlow_ui_messages_items_type {
  info
  error
  success
}

"Nodes are represented as HTML elements or their native UI equivalents. For example,\na node can be an `<img>` tag, or an `<input element>` but also `some plain text`."
type Node_represents_a_flow_SINGLE_QUOTE_s_nodes {
  attributes: Attributes_represents_a_list_of_attributes_e_g___BACKTICK_href_EQUALS__QUOTATION_MARK_foo_QUOTATION_MARK__BACKTICK__for_links_!
  group: query_createNativeLoginFlow_ui_nodes_items_group!
  messages: [uiText]!
  meta: A_Node_SINGLE_QUOTE_s_Meta_Information!
  type: query_createNativeLoginFlow_ui_nodes_items_type!
}

union Attributes_represents_a_list_of_attributes_e_g___BACKTICK_href_EQUALS__QUOTATION_MARK_foo_QUOTATION_MARK__BACKTICK__for_links_ @discriminator(field: "node_type") = uiNodeInputAttributes | TextAttributes_represents_the_attributes_of_a_text_node_ | ImageAttributes_represents_the_attributes_of_an_image_node_ | AnchorAttributes_represents_the_attributes_of_an_anchor_node_ | ScriptAttributes_represent_script_nodes_which_load_javascript_

"InputAttributes represents the attributes of an input node"
type uiNodeInputAttributes {
  autocomplete: query_createNativeLoginFlow_ui_nodes_items_attributes_oneOf_0_autocomplete
  "Sets the input's disabled field to true or false."
  disabled: Boolean!
  label: uiText
  "The input's element name."
  name: String!
  "NodeType represents this node's types. It is a mirror of `node.type` and\nis primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \"input\"."
  node_type: String!
  "OnClick may contain javascript which should be executed on click. This is primarily\nused for WebAuthn."
  onclick: String
  "The input's pattern."
  pattern: String
  "Mark this input field as required."
  required: Boolean
  type: query_createNativeLoginFlow_ui_nodes_items_attributes_oneOf_0_type!
  "The input's value."
  value: String
}

"The autocomplete attribute for the input.\nemail InputAttributeAutocompleteEmail\ntel InputAttributeAutocompleteTel\nurl InputAttributeAutocompleteUrl\ncurrent-password InputAttributeAutocompleteCurrentPassword\nnew-password InputAttributeAutocompleteNewPassword\none-time-code InputAttributeAutocompleteOneTimeCode"
enum query_createNativeLoginFlow_ui_nodes_items_attributes_oneOf_0_autocomplete {
  email
  tel
  url
  current_password @enum(value: "\"current-password\"")
  new_password @enum(value: "\"new-password\"")
  one_time_code @enum(value: "\"one-time-code\"")
}

"The input's element type.\ntext InputAttributeTypeText\npassword InputAttributeTypePassword\nnumber InputAttributeTypeNumber\ncheckbox InputAttributeTypeCheckbox\nhidden InputAttributeTypeHidden\nemail InputAttributeTypeEmail\ntel InputAttributeTypeTel\nsubmit InputAttributeTypeSubmit\nbutton InputAttributeTypeButton\ndatetime-local InputAttributeTypeDateTimeLocal\ndate InputAttributeTypeDate\nurl InputAttributeTypeURI"
enum query_createNativeLoginFlow_ui_nodes_items_attributes_oneOf_0_type {
  text
  password
  number
  checkbox
  hidden
  email
  tel
  submit
  button
  datetime_local @enum(value: "\"datetime-local\"")
  date
  url
}

type TextAttributes_represents_the_attributes_of_a_text_node_ {
  "A unique identifier"
  id: String!
  "NodeType represents this node's types. It is a mirror of `node.type` and\nis primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \"text\"."
  node_type: String!
  text: uiText!
}

type ImageAttributes_represents_the_attributes_of_an_image_node_ {
  "Height of the image"
  height: Int!
  "A unique identifier"
  id: String!
  "NodeType represents this node's types. It is a mirror of `node.type` and\nis primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \"img\"."
  node_type: String!
  "The image's source URL.\n\nformat: uri"
  src: String!
  "Width of the image"
  width: Int!
}

type AnchorAttributes_represents_the_attributes_of_an_anchor_node_ {
  "The link's href (destination) URL.\n\nformat: uri"
  href: String!
  "A unique identifier"
  id: String!
  "NodeType represents this node's types. It is a mirror of `node.type` and\nis primarily used to allow compatibility with OpenAPI 3.0.  In this struct it technically always is \"a\"."
  node_type: String!
  title: uiText!
}

type ScriptAttributes_represent_script_nodes_which_load_javascript_ {
  "The script async type"
  async: Boolean!
  "The script cross origin policy"
  crossorigin: String!
  "A unique identifier"
  id: String!
  "The script's integrity hash"
  integrity: String!
  "NodeType represents this node's types. It is a mirror of `node.type` and\nis primarily used to allow compatibility with OpenAPI 3.0. In this struct it technically always is \"script\"."
  node_type: String!
  "Nonce for CSP\n\nA nonce you may want to use to improve your Content Security Policy.\nYou do not have to use this value but if you want to improve your CSP\npolicies you may use it. You can also choose to use your own nonce value!"
  nonce: String!
  "The script referrer policy"
  referrerpolicy: String!
  "The script source"
  src: String!
  "The script MIME type"
  type: String!
}

"Group specifies which group (e.g. password authenticator) this node belongs to.\ndefault DefaultGroup\npassword PasswordGroup\noidc OpenIDConnectGroup\nprofile ProfileGroup\nlink LinkGroup\ncode CodeGroup\ntotp TOTPGroup\nlookup_secret LookupGroup\nwebauthn WebAuthnGroup"
enum query_createNativeLoginFlow_ui_nodes_items_group {
  default
  password
  oidc
  profile
  link
  code
  totp
  lookup_secret
  webauthn
}

"This might include a label and other information that can optionally\nbe used to render UIs."
type A_Node_SINGLE_QUOTE_s_Meta_Information {
  label: uiText
}

"The node's type\ntext Text\ninput Input\nimg Image\na Anchor\nscript Script"
enum query_createNativeLoginFlow_ui_nodes_items_type {
  text
  input
  img
  a
  script
}

"Logout Flow"
type logoutFlow {
  "LogoutToken can be used to perform logout using AJAX."
  logout_token: String!
  "LogoutURL can be opened in a browser to sign the user out.\n\nformat: uri"
  logout_url: String!
}

"This request is used when an identity wants to recover their account.\n\nWe recommend reading the [Account Recovery Documentation](../self-service/flows/password-reset-account-recovery)"
type A_Recovery_Flow {
  "Active, if set, contains the recovery method that is being used. It is initially\nnot set."
  active: String
  "ExpiresAt is the time (UTC) when the request expires. If the user still wishes to update the setting,\na new request has to be initiated."
  expires_at: DateTime!
  "ID represents the request's unique ID. When performing the recovery flow, this\nrepresents the id in the recovery ui's query parameter: http://<selfservice.flows.recovery.ui_url>?request=<id>"
  id: UUID!
  "IssuedAt is the time (UTC) when the request occurred."
  issued_at: DateTime!
  "RequestURL is the initial URL that was requested from Ory Kratos. It can be used\nto forward information contained in the URL's path or query for example."
  request_url: String!
  "ReturnTo contains the requested return_to URL."
  return_to: String
  state: Recovery_Flow_State!
  "The flow type can either be `api` or `browser`."
  type: String!
  ui: uiContainer!
}

"The state represents the state of the recovery flow.\n\nchoose_method: ask the user to choose a method (e.g. recover account via email)\nsent_email: the email has been sent to the user\npassed_challenge: the request was successful and the recovery challenge was passed."
enum Recovery_Flow_State {
  choose_method
  sent_email
  passed_challenge
}

type registrationFlow {
  active: CredentialsType__represents_several_different_credential_types_COMMA__like_password_credentials_COMMA__passwordless_credentials_COMMA_
  "ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to log in,\na new flow has to be initiated."
  expires_at: DateTime!
  "ID represents the flow's unique ID. When performing the registration flow, this\nrepresents the id in the registration ui's query parameter: http://<selfservice.flows.registration.ui_url>/?flow=<id>"
  id: UUID!
  "IssuedAt is the time (UTC) when the flow occurred."
  issued_at: DateTime!
  oauth2_login_challenge: String
  oauth2_login_request: OAuth2LoginRequest
  "RequestURL is the initial URL that was requested from Ory Kratos. It can be used\nto forward information contained in the URL's path or query for example."
  request_url: String!
  "ReturnTo contains the requested return_to URL."
  return_to: String
  "The flow type can either be `api` or `browser`."
  type: String!
  ui: uiContainer!
}

"This flow is used when an identity wants to update settings\n(e.g. profile data, passwords, ...) in a selfservice manner.\n\nWe recommend reading the [User Settings Documentation](../self-service/flows/user-settings)"
type Flow_represents_a_Settings_Flow {
  "Active, if set, contains the registration method that is being used. It is initially\nnot set."
  active: String
  "ExpiresAt is the time (UTC) when the flow expires. If the user still wishes to update the setting,\na new flow has to be initiated."
  expires_at: DateTime!
  "ID represents the flow's unique ID. When performing the settings flow, this\nrepresents the id in the settings ui's query parameter: http://<selfservice.flows.settings.ui_url>?flow=<id>"
  id: UUID!
  identity: KratosIdentity!
  "IssuedAt is the time (UTC) when the flow occurred."
  issued_at: DateTime!
  "RequestURL is the initial URL that was requested from Ory Kratos. It can be used\nto forward information contained in the URL's path or query for example."
  request_url: String!
  "ReturnTo contains the requested return_to URL."
  return_to: String
  state: State_represents_the_state_of_this_flow__It_knows_two_states_!
  "The flow type can either be `api` or `browser`."
  type: String!
  ui: uiContainer!
}

"show_form: No user data has been collected, or it is invalid, and thus the form should be shown.\nsuccess: Indicates that the settings flow has been updated successfully with the provided data.\nDone will stay true when repeatedly checking. If set to true, done will revert back to false only\nwhen a flow with invalid (e.g. \"please use a valid phone number\") data was sent."
enum State_represents_the_state_of_this_flow__It_knows_two_states_ {
  show_form
  success
}

"Used to verify an out-of-band communication\nchannel such as an email address or a phone number.\n\nFor more information head over to: https://www.ory.sh/docs/kratos/selfservice/flows/verify-email-account-activation"
type A_Verification_Flow {
  "Active, if set, contains the registration method that is being used. It is initially\nnot set."
  active: String
  "ExpiresAt is the time (UTC) when the request expires. If the user still wishes to verify the address,\na new request has to be initiated."
  expires_at: DateTime
  "ID represents the request's unique ID. When performing the verification flow, this\nrepresents the id in the verify ui's query parameter: http://<selfservice.flows.verification.ui_url>?request=<id>\n\ntype: string\nformat: uuid"
  id: UUID!
  "IssuedAt is the time (UTC) when the request occurred."
  issued_at: DateTime
  "RequestURL is the initial URL that was requested from Ory Kratos. It can be used\nto forward information contained in the URL's path or query for example."
  request_url: String
  "ReturnTo contains the requested return_to URL."
  return_to: String
  state: Verification_Flow_State!
  "The flow type can either be `api` or `browser`."
  type: String!
  ui: uiContainer!
}

"The state represents the state of the verification flow.\n\nchoose_method: ask the user to choose a method (e.g. recover account via email)\nsent_email: the email has been sent to the user\npassed_challenge: the request was successful and the recovery challenge was passed."
enum Verification_Flow_State {
  choose_method
  sent_email
  passed_challenge
}

"Create Identity Body"
input createIdentityBody_Input {
  credentials: identityWithCredentials_Input
  "Store metadata about the user which is only accessible through admin APIs such as `GET /admin/identities/<id>`."
  metadata_admin: JSON
  "Store metadata about the identity which the identity itself can see when calling for example the\nsession endpoint. Do not store sensitive information (e.g. credit score) about the identity in this field."
  metadata_public: JSON
  "RecoveryAddresses contains all the addresses that can be used to recover an identity.\n\nUse this structure to import recovery addresses for an identity. Please keep in mind\nthat the address needs to be represented in the Identity Schema or this field will be overwritten\non the next identity update."
  recovery_addresses: [recoveryIdentityAddress_Input]
  "SchemaID is the ID of the JSON Schema to be used for validating the identity's traits."
  schema_id: String!
  state: An_Identity_SINGLE_QUOTE_s_State
  traits: JSON!
  "VerifiableAddresses contains all the addresses that can be verified by the user.\n\nUse this structure to import verified addresses for an identity. Please keep in mind\nthat the address needs to be represented in the Identity Schema or this field will be overwritten\non the next identity update."
  verifiable_addresses: [verifiableIdentityAddress_Input]
}

"Create Identity and Import Credentials"
input identityWithCredentials_Input {
  oidc: identityWithCredentialsOidc_Input
  password: identityWithCredentialsPassword_Input
}

"Create Identity and Import Social Sign In Credentials"
input identityWithCredentialsOidc_Input {
  config: identityWithCredentialsOidcConfig_Input
}

input identityWithCredentialsOidcConfig_Input {
  config: identityWithCredentialsPasswordConfig_Input
  "A list of OpenID Connect Providers"
  providers: [identityWithCredentialsOidcConfigProvider_Input]
}

"Create Identity and Import Password Credentials Configuration"
input identityWithCredentialsPasswordConfig_Input {
  "The hashed password in [PHC format]( https://www.ory.sh/docs/kratos/concepts/credentials/username-email-password#hashed-password-format)"
  hashed_password: String
  "The password in plain text if no hash is available."
  password: String
}

"Create Identity and Import Social Sign In Credentials Configuration"
input identityWithCredentialsOidcConfigProvider_Input {
  "The OpenID Connect provider to link the subject to. Usually something like `google` or `github`."
  provider: String!
  "The subject (`sub`) of the OpenID Connect connection. Usually the `sub` field of the ID Token."
  subject: String!
}

"Create Identity and Import Password Credentials"
input identityWithCredentialsPassword_Input {
  config: identityWithCredentialsPasswordConfig_Input
}

input recoveryIdentityAddress_Input {
  "CreatedAt is a helper struct field for gobuffalo.pop."
  created_at: DateTime
  id: UUID!
  "UpdatedAt is a helper struct field for gobuffalo.pop."
  updated_at: DateTime
  value: String!
  via: String!
}

"VerifiableAddress is an identity's verifiable address"
input verifiableIdentityAddress_Input {
  "When this entry was created"
  created_at: DateTime
  "The ID"
  id: UUID
  "VerifiableAddressStatus must not exceed 16 characters as that is the limitation in the SQL Schema"
  status: String!
  "When this entry was last updated"
  updated_at: DateTime
  "The address value\n\nexample foo@user.com"
  value: String!
  "Indicates if the address has already been verified"
  verified: Boolean!
  verified_at: DateTime
  "VerifiableAddressType must not exceed 16 characters as that is the limitation in the SQL Schema"
  via: String!
}

"A JSONPatch document as defined by RFC 6902"
input jsonPatch_Input {
  "This field is used together with operation \"move\" and uses JSON Pointer notation.\n\nLearn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5)."
  from: String
  "The operation to be performed. One of \"add\", \"remove\", \"replace\", \"move\", \"copy\", or \"test\"."
  op: String!
  "The path to the target path. Uses JSON pointer notation.\n\nLearn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5)."
  path: String!
  "The value to be used within the operations.\n\nLearn more [about JSON Pointers](https://datatracker.ietf.org/doc/html/rfc6901#section-5)."
  value: String
}

"Update Identity Body"
input updateIdentityBody_Input {
  credentials: identityWithCredentials_Input
  "Store metadata about the user which is only accessible through admin APIs such as `GET /admin/identities/<id>`."
  metadata_admin: JSON
  "Store metadata about the identity which the identity itself can see when calling for example the\nsession endpoint. Do not store sensitive information (e.g. credit score) about the identity in this field."
  metadata_public: JSON
  "SchemaID is the ID of the JSON Schema to be used for validating the identity's traits. If set\nwill update the Identity's SchemaID."
  schema_id: String!
  state: An_Identity_SINGLE_QUOTE_s_State!
  traits: JSON!
}

"Used when an administrator creates a recovery code for an identity."
type Recovery_Code_for_Identity {
  "Expires At is the timestamp of when the recovery flow expires\n\nThe timestamp when the recovery link expires."
  expires_at: DateTime
  "RecoveryCode is the code that can be used to recover the account"
  recovery_code: String!
  "RecoveryLink with flow\n\nThis link opens the recovery UI with an empty `code` field."
  recovery_link: String!
}

"Create Recovery Code for Identity Request Body"
input createRecoveryCodeForIdentityBody_Input {
  expires_in: mutationInput_createRecoveryCodeForIdentity_input_expires_in
  "Identity to Recover\n\nThe identity's ID you wish to recover."
  identity_id: UUID!
}

scalar mutationInput_createRecoveryCodeForIdentity_input_expires_in @regexp(pattern: "^([0-9]+(ns|us|ms|s|m|h))*$") @typescript(type: "string")

"Used when an administrator creates a recovery link for an identity."
type Identity_Recovery_Link {
  "Recovery Link Expires At\n\nThe timestamp when the recovery link expires."
  expires_at: DateTime
  "Recovery Link\n\nThis link can be used to recover the account."
  recovery_link: String!
}

"Create Recovery Link for Identity Request Body"
input createRecoveryLinkForIdentityBody_Input {
  expires_in: mutationInput_createRecoveryLinkForIdentity_input_expires_in
  "Identity to Recover\n\nThe identity's ID you wish to recover."
  identity_id: UUID!
}

scalar mutationInput_createRecoveryLinkForIdentity_input_expires_in @regexp(pattern: "^[0-9]+(ns|us|ms|s|m|h)$") @typescript(type: "string")

"The Response for Login Flows via API"
type successfulNativeLogin {
  session: session!
  "The Session Token\n\nA session token is equivalent to a session cookie, but it can be sent in the HTTP Authorization\nHeader:\n\nAuthorization: bearer ${session-token}\n\nThe session token is only issued for API flows, not for Browser flows!"
  session_token: String
}

input updateLoginFlowBody_Input @oneOf {
  updateLoginFlowWithPasswordMethod_Input: updateLoginFlowWithPasswordMethod_Input
  updateLoginFlowWithOidcMethod_Input: updateLoginFlowWithOidcMethod_Input
  updateLoginFlowWithTotpMethod_Input: updateLoginFlowWithTotpMethod_Input
  updateLoginFlowWithWebAuthnMethod_Input: updateLoginFlowWithWebAuthnMethod_Input
  updateLoginFlowWithLookupSecretMethod_Input: updateLoginFlowWithLookupSecretMethod_Input
}

"Update Login Flow with Password Method"
input updateLoginFlowWithPasswordMethod_Input {
  "Sending the anti-csrf token is only required for browser login flows."
  csrf_token: String
  "Identifier is the email or username of the user trying to log in."
  identifier: String!
  "Method should be set to \"password\" when logging in using the identifier and password strategy."
  method: String!
  "The user's password."
  password: String!
  "Identifier is the email or username of the user trying to log in.\nThis field is deprecated!"
  password_identifier: String
}

"Update Login Flow with OpenID Connect Method"
input updateLoginFlowWithOidcMethod_Input {
  "The CSRF Token"
  csrf_token: String
  "Method to use\n\nThis field must be set to `oidc` when using the oidc method."
  method: String!
  "The provider to register with"
  provider: String!
  traits: JSON
}

"Update Login Flow with TOTP Method"
input updateLoginFlowWithTotpMethod_Input {
  "Sending the anti-csrf token is only required for browser login flows."
  csrf_token: String
  "Method should be set to \"totp\" when logging in using the TOTP strategy."
  method: String!
  "The TOTP code."
  totp_code: String!
}

"Update Login Flow with WebAuthn Method"
input updateLoginFlowWithWebAuthnMethod_Input {
  "Sending the anti-csrf token is only required for browser login flows."
  csrf_token: String
  "Identifier is the email or username of the user trying to log in."
  identifier: String!
  "Method should be set to \"webAuthn\" when logging in using the WebAuthn strategy."
  method: String!
  "Login a WebAuthn Security Key\n\nThis must contain the ID of the WebAuthN connection."
  webauthn_login: String
}

"Update Login Flow with Lookup Secret Method"
input updateLoginFlowWithLookupSecretMethod_Input {
  "Sending the anti-csrf token is only required for browser login flows."
  csrf_token: String
  "The lookup secret."
  lookup_secret: String!
  "Method should be set to \"lookup_secret\" when logging in using the lookup_secret strategy."
  method: String!
}

"nolint:deadcode,unused"
input Perform_Native_Logout_Request_Body_Input {
  "The Session Token\n\nInvalidate this session token."
  session_token: String!
}

input updateRecoveryFlowBody_Input @oneOf {
  updateRecoveryFlowWithLinkMethod_Input: updateRecoveryFlowWithLinkMethod_Input
  updateRecoveryFlowWithCodeMethod_Input: updateRecoveryFlowWithCodeMethod_Input
}

"Update Recovery Flow with Link Method"
input updateRecoveryFlowWithLinkMethod_Input {
  "Sending the anti-csrf token is only required for browser login flows."
  csrf_token: String
  "Email to Recover\n\nNeeds to be set when initiating the flow. If the email is a registered\nrecovery email, a recovery link will be sent. If the email is not known,\na email with details on what happened will be sent instead.\n\nformat: email"
  email: String!
  "Method supports `link` only right now."
  method: String!
}

"Update Recovery Flow with Code Method"
input updateRecoveryFlowWithCodeMethod_Input {
  "Code from recovery email\n\nSent to the user once a recovery has been initiated and is used to prove\nthat the user is in possession of the email"
  code: String
  "Sending the anti-csrf token is only required for browser login flows."
  csrf_token: String
  "Email to Recover\n\nNeeds to be set when initiating the flow. If the email is a registered\nrecovery email, a recovery link will be sent. If the email is not known,\na email with details on what happened will be sent instead.\n\nformat: email"
  email: String
  "Method supports `link` and `code` only right now."
  method: String!
}

"The Response for Registration Flows via API"
type successfulNativeRegistration {
  identity: KratosIdentity!
  session: session
  "The Session Token\n\nThis field is only set when the session hook is configured as a post-registration hook.\n\nA session token is equivalent to a session cookie, but it can be sent in the HTTP Authorization\nHeader:\n\nAuthorization: bearer ${session-token}\n\nThe session token is only issued for API flows, not for Browser flows!"
  session_token: String
}

input updateRegistrationFlowBody_Input @oneOf {
  updateRegistrationFlowWithPasswordMethod_Input: updateRegistrationFlowWithPasswordMethod_Input
  updateRegistrationFlowWithOidcMethod_Input: updateRegistrationFlowWithOidcMethod_Input
  updateRegistrationFlowWithWebAuthnMethod_Input: updateRegistrationFlowWithWebAuthnMethod_Input
}

"Update Registration Flow with Password Method"
input updateRegistrationFlowWithPasswordMethod_Input {
  "The CSRF Token"
  csrf_token: String
  "Method to use\n\nThis field must be set to `password` when using the password method."
  method: String!
  "Password to sign the user up with"
  password: String!
  traits: JSON!
}

"Update Registration Flow with OpenID Connect Method"
input updateRegistrationFlowWithOidcMethod_Input {
  "The CSRF Token"
  csrf_token: String
  "Method to use\n\nThis field must be set to `oidc` when using the oidc method."
  method: String!
  "The provider to register with"
  provider: String!
  traits: JSON
}

"Update Registration Flow with WebAuthn Method"
input updateRegistrationFlowWithWebAuthnMethod_Input {
  "CSRFToken is the anti-CSRF token"
  csrf_token: String
  "Method\n\nShould be set to \"webauthn\" when trying to add, update, or remove a webAuthn pairing."
  method: String!
  traits: JSON!
  "Register a WebAuthn Security Key\n\nIt is expected that the JSON returned by the WebAuthn registration process\nis included here."
  webauthn_register: String
  "Name of the WebAuthn Security Key to be Added\n\nA human-readable name for the security key which will be added."
  webauthn_register_displayname: String
}

input updateSettingsFlowBody_Input @oneOf {
  updateSettingsFlowWithPasswordMethod_Input: updateSettingsFlowWithPasswordMethod_Input
  Update_Settings_Flow_with_Profile_Method_Input: Update_Settings_Flow_with_Profile_Method_Input
  Update_Settings_Flow_with_OpenID_Connect_Method_Input: Update_Settings_Flow_with_OpenID_Connect_Method_Input
  updateSettingsFlowWithTotpMethod_Input: updateSettingsFlowWithTotpMethod_Input
  updateSettingsFlowWithWebAuthnMethod_Input: updateSettingsFlowWithWebAuthnMethod_Input
  updateSettingsFlowWithLookupMethod_Input: updateSettingsFlowWithLookupMethod_Input
}

"Update Settings Flow with Password Method"
input updateSettingsFlowWithPasswordMethod_Input {
  "CSRFToken is the anti-CSRF token"
  csrf_token: String
  "Method\n\nShould be set to password when trying to update a password."
  method: String!
  "Password is the updated password"
  password: String!
}

"nolint:deadcode,unused"
input Update_Settings_Flow_with_Profile_Method_Input {
  "The Anti-CSRF Token\n\nThis token is only required when performing browser flows."
  csrf_token: String
  "Method\n\nShould be set to profile when trying to update a profile."
  method: String!
  traits: JSON!
}

"nolint:deadcode,unused"
input Update_Settings_Flow_with_OpenID_Connect_Method_Input {
  "Flow ID is the flow's ID.\n\nin: query"
  flow: String
  "Link this provider\n\nEither this or `unlink` must be set.\n\ntype: string\nin: body"
  link: String
  "Method\n\nShould be set to profile when trying to update a profile."
  method: String!
  traits: JSON
  "Unlink this provider\n\nEither this or `link` must be set.\n\ntype: string\nin: body"
  unlink: String
}

"Update Settings Flow with TOTP Method"
input updateSettingsFlowWithTotpMethod_Input {
  "CSRFToken is the anti-CSRF token"
  csrf_token: String
  "Method\n\nShould be set to \"totp\" when trying to add, update, or remove a totp pairing."
  method: String!
  "ValidationTOTP must contain a valid TOTP based on the"
  totp_code: String
  "UnlinkTOTP if true will remove the TOTP pairing,\neffectively removing the credential. This can be used\nto set up a new TOTP device."
  totp_unlink: Boolean
}

"Update Settings Flow with WebAuthn Method"
input updateSettingsFlowWithWebAuthnMethod_Input {
  "CSRFToken is the anti-CSRF token"
  csrf_token: String
  "Method\n\nShould be set to \"webauthn\" when trying to add, update, or remove a webAuthn pairing."
  method: String!
  "Register a WebAuthn Security Key\n\nIt is expected that the JSON returned by the WebAuthn registration process\nis included here."
  webauthn_register: String
  "Name of the WebAuthn Security Key to be Added\n\nA human-readable name for the security key which will be added."
  webauthn_register_displayname: String
  "Remove a WebAuthn Security Key\n\nThis must contain the ID of the WebAuthN connection."
  webauthn_remove: String
}

"Update Settings Flow with Lookup Method"
input updateSettingsFlowWithLookupMethod_Input {
  "CSRFToken is the anti-CSRF token"
  csrf_token: String
  "If set to true will save the regenerated lookup secrets"
  lookup_secret_confirm: Boolean
  "Disables this method if true."
  lookup_secret_disable: Boolean
  "If set to true will regenerate the lookup secrets"
  lookup_secret_regenerate: Boolean
  "If set to true will reveal the lookup secrets"
  lookup_secret_reveal: Boolean
  "Method\n\nShould be set to \"lookup\" when trying to add, update, or remove a lookup pairing."
  method: String!
}

"Update Verification Flow with Link Method"
input updateVerificationFlowWithLinkMethod_Input {
  "Sending the anti-csrf token is only required for browser login flows."
  csrf_token: String
  "Email to Verify\n\nNeeds to be set when initiating the flow. If the email is a registered\nverification email, a verification link will be sent. If the email is not known,\na email with details on what happened will be sent instead.\n\nformat: email"
  email: String!
  "Method supports `link` only right now."
  method: String!
}

"Deleted Session Count"
type deleteMySessionsCount {
  "The number of sessions that were revoked."
  count: Int
}

"""
The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.

#### Live Queries

Live query fields are differentiated by containing `(live)` at the end of their
description, they are added for each field in the `Query` type. When you
subscribe to a live query field, the selection set will be evaluated and sent to
the client, and then most things\* that would cause the output of the selection
set to change will trigger the selection set to be re-evaluated and the results
to be re-sent to the client.

_(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_

Live queries can be very expensive, so try and keep them small and focussed.

#### Events

Event fields will run their selection set when, and only when, the specified
server-side event occurs. This makes them a lot more efficient than Live
Queries, but it is still recommended that you keep payloads fairly small.
"""
type Subscription {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form. (live)
  """
  query: Query!
  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live)
  """
  nodeId: ID!
  """Fetches an object given its globally unique `ID`. (live)"""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node
  """Reads and enables pagination through a set of `Client`. (live)"""
  clients(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Client`."""
    orderBy: [ClientsOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientFilter
  ): ClientsConnection
  """Reads a set of `Client`. (live)"""
  clientsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Client`."""
    orderBy: [ClientsOrderBy!]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientFilter
  ): [Client!]
  """Reads and enables pagination through a set of `Entry`. (live)"""
  entries(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Entry`."""
    orderBy: [EntriesOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EntryCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EntryFilter
  ): EntriesConnection
  """Reads a set of `Entry`. (live)"""
  entriesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Entry`."""
    orderBy: [EntriesOrderBy!]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EntryCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EntryFilter
  ): [Entry!]
  """Reads and enables pagination through a set of `EntryTag`. (live)"""
  entryTags(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `EntryTag`."""
    orderBy: [EntryTagsOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EntryTagCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EntryTagFilter
  ): EntryTagsConnection
  """Reads a set of `EntryTag`. (live)"""
  entryTagsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `EntryTag`."""
    orderBy: [EntryTagsOrderBy!]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EntryTagCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EntryTagFilter
  ): [EntryTag!]
  """Reads and enables pagination through a set of `Project`. (live)"""
  projects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter
  ): ProjectsConnection
  """Reads a set of `Project`. (live)"""
  projectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter
  ): [Project!]
  """
  Reads and enables pagination through a set of `SchemaMigration`. (live)
  """
  schemaMigrations(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `SchemaMigration`."""
    orderBy: [SchemaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SchemaMigrationCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SchemaMigrationFilter
  ): SchemaMigrationsConnection
  """Reads a set of `SchemaMigration`. (live)"""
  schemaMigrationsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `SchemaMigration`."""
    orderBy: [SchemaMigrationsOrderBy!]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SchemaMigrationCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SchemaMigrationFilter
  ): [SchemaMigration!]
  """Reads and enables pagination through a set of `Tag`. (live)"""
  tags(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TagFilter
  ): TagsConnection
  """Reads a set of `Tag`. (live)"""
  tagsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TagFilter
  ): [Tag!]
  """ (live)"""
  client(userId: String!, id: String!): Client
  """ (live)"""
  clientByName(name: String!): Client
  """ (live)"""
  entry(userId: String!, id: String!): Entry
  """ (live)"""
  entryTag(userId: String!, entryId: String!, tagId: String!): EntryTag
  """ (live)"""
  project(userId: String!, id: String!): Project
  """ (live)"""
  projectByName(name: String!): Project
  """ (live)"""
  schemaMigration(version: BigInt!): SchemaMigration
  """ (live)"""
  tag(userId: String!, id: String!): Tag
  """ (live)"""
  tagByName(name: String!): Tag
  """Reads a single `Client` using its globally unique `ID`. (live)"""
  clientByNodeId(
    """The globally unique `ID` to be used in selecting a single `Client`."""
    nodeId: ID!
  ): Client
  """Reads a single `Entry` using its globally unique `ID`. (live)"""
  entryByNodeId(
    """The globally unique `ID` to be used in selecting a single `Entry`."""
    nodeId: ID!
  ): Entry
  """Reads a single `EntryTag` using its globally unique `ID`. (live)"""
  entryTagByNodeId(
    """The globally unique `ID` to be used in selecting a single `EntryTag`."""
    nodeId: ID!
  ): EntryTag
  """Reads a single `Project` using its globally unique `ID`. (live)"""
  projectByNodeId(
    """The globally unique `ID` to be used in selecting a single `Project`."""
    nodeId: ID!
  ): Project
  """
  Reads a single `SchemaMigration` using its globally unique `ID`. (live)
  """
  schemaMigrationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `SchemaMigration`.
    """
    nodeId: ID!
  ): SchemaMigration
  """Reads a single `Tag` using its globally unique `ID`. (live)"""
  tagByNodeId(
    """The globally unique `ID` to be used in selecting a single `Tag`."""
    nodeId: ID!
  ): Tag
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `Client` values."""
type ClientsConnection {
  """A list of `Client` objects."""
  nodes: [Client]!
  """
  A list of edges which contains the `Client` and cursor to aid in pagination.
  """
  edges: [ClientsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Client` you could get from the connection."""
  totalCount: Int!
}

type Client implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  userId: String!
  id: String!
  name: String!
  """Reads and enables pagination through a set of `Project`."""
  projectsByUserIdAndClientId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByUserIdAndClientIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProjectFilter
  ): [Project!]!
}

"""A connection to a list of `Project` values."""
type ProjectsConnection {
  """A list of `Project` objects."""
  nodes: [Project]!
  """
  A list of edges which contains the `Project` and cursor to aid in pagination.
  """
  edges: [ProjectsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!
}

type Project implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  userId: String!
  id: String!
  name: String!
  clientId: String
  """Reads a single `Client` that is related to this `Project`."""
  userClient: Client
}

"""A `Project` edge in the connection."""
type ProjectsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Project` at the end of the edge."""
  node: Project
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `Project`."""
enum ProjectsOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Project` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ProjectCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: String
  """Checks for equality with the object’s `id` field."""
  id: String
  """Checks for equality with the object’s `name` field."""
  name: String
  """Checks for equality with the object’s `clientId` field."""
  clientId: String
}

"""
A filter to be used against `Project` object types. All fields are combined with a logical ‘and.’
"""
input ProjectFilter {
  """Filter by the object’s `userId` field."""
  userId: StringFilter
  """Filter by the object’s `id` field."""
  id: StringFilter
  """Filter by the object’s `name` field."""
  name: StringFilter
  """Filter by the object’s `clientId` field."""
  clientId: StringFilter
  """Checks for all expressions in this list."""
  and: [ProjectFilter!]
  """Checks for any expressions in this list."""
  or: [ProjectFilter!]
  """Negates the expression."""
  not: ProjectFilter
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean
  """Equal to the specified value."""
  equalTo: String
  """Not equal to the specified value."""
  notEqualTo: String
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String
  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String
  """Included in the specified list."""
  in: [String!]
  """Not included in the specified list."""
  notIn: [String!]
  """Less than the specified value."""
  lessThan: String
  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String
  """Greater than the specified value."""
  greaterThan: String
  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String
  """Contains the specified string (case-sensitive)."""
  includes: String
  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String
  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String
  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String
  """Starts with the specified string (case-sensitive)."""
  startsWith: String
  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String
  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String
  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String
  """Ends with the specified string (case-sensitive)."""
  endsWith: String
  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String
  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String
  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String
  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String
  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String
  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String
  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String
  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String
  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String
  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String
  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String
  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]
  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]
  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String
  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String
  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String
  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String
}

"""A `Client` edge in the connection."""
type ClientsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Client` at the end of the edge."""
  node: Client
}

"""Methods to use when ordering `Client`."""
enum ClientsOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Client` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ClientCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: String
  """Checks for equality with the object’s `id` field."""
  id: String
  """Checks for equality with the object’s `name` field."""
  name: String
}

"""
A filter to be used against `Client` object types. All fields are combined with a logical ‘and.’
"""
input ClientFilter {
  """Filter by the object’s `userId` field."""
  userId: StringFilter
  """Filter by the object’s `id` field."""
  id: StringFilter
  """Filter by the object’s `name` field."""
  name: StringFilter
  """Checks for all expressions in this list."""
  and: [ClientFilter!]
  """Checks for any expressions in this list."""
  or: [ClientFilter!]
  """Negates the expression."""
  not: ClientFilter
}

"""A connection to a list of `Entry` values."""
type EntriesConnection {
  """A list of `Entry` objects."""
  nodes: [Entry]!
  """
  A list of edges which contains the `Entry` and cursor to aid in pagination.
  """
  edges: [EntriesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Entry` you could get from the connection."""
  totalCount: Int!
}

type Entry implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  userId: String!
  id: String!
  start: Datetime!
  status: Int!
  description: String
  lastStart: Datetime!
  lastStop: Datetime
  lastDuration: Int!
  totalDuration: Int!
  projectId: String
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""A `Entry` edge in the connection."""
type EntriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Entry` at the end of the edge."""
  node: Entry
}

"""Methods to use when ordering `Entry`."""
enum EntriesOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  ID_ASC
  ID_DESC
  START_ASC
  START_DESC
  STATUS_ASC
  STATUS_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  LAST_START_ASC
  LAST_START_DESC
  LAST_STOP_ASC
  LAST_STOP_DESC
  LAST_DURATION_ASC
  LAST_DURATION_DESC
  TOTAL_DURATION_ASC
  TOTAL_DURATION_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Entry` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input EntryCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: String
  """Checks for equality with the object’s `id` field."""
  id: String
  """Checks for equality with the object’s `start` field."""
  start: Datetime
  """Checks for equality with the object’s `status` field."""
  status: Int
  """Checks for equality with the object’s `description` field."""
  description: String
  """Checks for equality with the object’s `lastStart` field."""
  lastStart: Datetime
  """Checks for equality with the object’s `lastStop` field."""
  lastStop: Datetime
  """Checks for equality with the object’s `lastDuration` field."""
  lastDuration: Int
  """Checks for equality with the object’s `totalDuration` field."""
  totalDuration: Int
  """Checks for equality with the object’s `projectId` field."""
  projectId: String
}

"""
A filter to be used against `Entry` object types. All fields are combined with a logical ‘and.’
"""
input EntryFilter {
  """Filter by the object’s `userId` field."""
  userId: StringFilter
  """Filter by the object’s `id` field."""
  id: StringFilter
  """Filter by the object’s `start` field."""
  start: DatetimeFilter
  """Filter by the object’s `status` field."""
  status: IntFilter
  """Filter by the object’s `description` field."""
  description: StringFilter
  """Filter by the object’s `lastStart` field."""
  lastStart: DatetimeFilter
  """Filter by the object’s `lastStop` field."""
  lastStop: DatetimeFilter
  """Filter by the object’s `lastDuration` field."""
  lastDuration: IntFilter
  """Filter by the object’s `totalDuration` field."""
  totalDuration: IntFilter
  """Filter by the object’s `projectId` field."""
  projectId: StringFilter
  """Checks for all expressions in this list."""
  and: [EntryFilter!]
  """Checks for any expressions in this list."""
  or: [EntryFilter!]
  """Negates the expression."""
  not: EntryFilter
}

"""
A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
"""
input DatetimeFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean
  """Equal to the specified value."""
  equalTo: Datetime
  """Not equal to the specified value."""
  notEqualTo: Datetime
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime
  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime
  """Included in the specified list."""
  in: [Datetime!]
  """Not included in the specified list."""
  notIn: [Datetime!]
  """Less than the specified value."""
  lessThan: Datetime
  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime
  """Greater than the specified value."""
  greaterThan: Datetime
  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean
  """Equal to the specified value."""
  equalTo: Int
  """Not equal to the specified value."""
  notEqualTo: Int
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int
  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int
  """Included in the specified list."""
  in: [Int!]
  """Not included in the specified list."""
  notIn: [Int!]
  """Less than the specified value."""
  lessThan: Int
  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int
  """Greater than the specified value."""
  greaterThan: Int
  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int
}

"""A connection to a list of `EntryTag` values."""
type EntryTagsConnection {
  """A list of `EntryTag` objects."""
  nodes: [EntryTag]!
  """
  A list of edges which contains the `EntryTag` and cursor to aid in pagination.
  """
  edges: [EntryTagsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `EntryTag` you could get from the connection."""
  totalCount: Int!
}

type EntryTag implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  userId: String!
  entryId: String!
  tagId: String!
}

"""A `EntryTag` edge in the connection."""
type EntryTagsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `EntryTag` at the end of the edge."""
  node: EntryTag
}

"""Methods to use when ordering `EntryTag`."""
enum EntryTagsOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  ENTRY_ID_ASC
  ENTRY_ID_DESC
  TAG_ID_ASC
  TAG_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `EntryTag` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input EntryTagCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: String
  """Checks for equality with the object’s `entryId` field."""
  entryId: String
  """Checks for equality with the object’s `tagId` field."""
  tagId: String
}

"""
A filter to be used against `EntryTag` object types. All fields are combined with a logical ‘and.’
"""
input EntryTagFilter {
  """Filter by the object’s `userId` field."""
  userId: StringFilter
  """Filter by the object’s `entryId` field."""
  entryId: StringFilter
  """Filter by the object’s `tagId` field."""
  tagId: StringFilter
  """Checks for all expressions in this list."""
  and: [EntryTagFilter!]
  """Checks for any expressions in this list."""
  or: [EntryTagFilter!]
  """Negates the expression."""
  not: EntryTagFilter
}

"""A connection to a list of `SchemaMigration` values."""
type SchemaMigrationsConnection {
  """A list of `SchemaMigration` objects."""
  nodes: [SchemaMigration]!
  """
  A list of edges which contains the `SchemaMigration` and cursor to aid in pagination.
  """
  edges: [SchemaMigrationsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """
  The count of *all* `SchemaMigration` you could get from the connection.
  """
  totalCount: Int!
}

type SchemaMigration implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  version: BigInt!
  dirty: Boolean!
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""A `SchemaMigration` edge in the connection."""
type SchemaMigrationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `SchemaMigration` at the end of the edge."""
  node: SchemaMigration
}

"""Methods to use when ordering `SchemaMigration`."""
enum SchemaMigrationsOrderBy {
  NATURAL
  VERSION_ASC
  VERSION_DESC
  DIRTY_ASC
  DIRTY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `SchemaMigration` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SchemaMigrationCondition {
  """Checks for equality with the object’s `version` field."""
  version: BigInt
  """Checks for equality with the object’s `dirty` field."""
  dirty: Boolean
}

"""
A filter to be used against `SchemaMigration` object types. All fields are combined with a logical ‘and.’
"""
input SchemaMigrationFilter {
  """Filter by the object’s `version` field."""
  version: BigIntFilter
  """Filter by the object’s `dirty` field."""
  dirty: BooleanFilter
  """Checks for all expressions in this list."""
  and: [SchemaMigrationFilter!]
  """Checks for any expressions in this list."""
  or: [SchemaMigrationFilter!]
  """Negates the expression."""
  not: SchemaMigrationFilter
}

"""
A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’
"""
input BigIntFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean
  """Equal to the specified value."""
  equalTo: BigInt
  """Not equal to the specified value."""
  notEqualTo: BigInt
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt
  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigInt
  """Included in the specified list."""
  in: [BigInt!]
  """Not included in the specified list."""
  notIn: [BigInt!]
  """Less than the specified value."""
  lessThan: BigInt
  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigInt
  """Greater than the specified value."""
  greaterThan: BigInt
  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigInt
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’
"""
input BooleanFilter {
  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean
  """Equal to the specified value."""
  equalTo: Boolean
  """Not equal to the specified value."""
  notEqualTo: Boolean
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean
  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean
  """Included in the specified list."""
  in: [Boolean!]
  """Not included in the specified list."""
  notIn: [Boolean!]
  """Less than the specified value."""
  lessThan: Boolean
  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean
  """Greater than the specified value."""
  greaterThan: Boolean
  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean
}

"""A connection to a list of `Tag` values."""
type TagsConnection {
  """A list of `Tag` objects."""
  nodes: [Tag]!
  """
  A list of edges which contains the `Tag` and cursor to aid in pagination.
  """
  edges: [TagsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Tag` you could get from the connection."""
  totalCount: Int!
}

type Tag implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  userId: String!
  id: String!
  name: String!
}

"""A `Tag` edge in the connection."""
type TagsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Tag` at the end of the edge."""
  node: Tag
}

"""Methods to use when ordering `Tag`."""
enum TagsOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TagCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: String
  """Checks for equality with the object’s `id` field."""
  id: String
  """Checks for equality with the object’s `name` field."""
  name: String
}

"""
A filter to be used against `Tag` object types. All fields are combined with a logical ‘and.’
"""
input TagFilter {
  """Filter by the object’s `userId` field."""
  userId: StringFilter
  """Filter by the object’s `id` field."""
  id: StringFilter
  """Filter by the object’s `name` field."""
  name: StringFilter
  """Checks for all expressions in this list."""
  and: [TagFilter!]
  """Checks for any expressions in this list."""
  or: [TagFilter!]
  """Negates the expression."""
  not: TagFilter
}